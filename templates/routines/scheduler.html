<style>

    .task-detail {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #ffffff;
        padding: 1.5rem;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 999;
        font-size: 0.975rem;
        width: 80vw;
        /* Set width to 80% of the viewport width */
        max-width: 500px;
        /* Optional: set a maximum width */
    }

    .overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 998;
    }
    .task-list {
        list-style: none;
        padding: 0;
        min-height: 300px;
        /* border: 2px dashed #ccc; */
        background-color: #88a9ca;
        border: solid 2px #ccc;
        border-radius: 8px;
    }

    .task-list .one-time-tasks {
        height: 600px;
        overflow-y: auto;
    }

    .task-item {
        padding: 0.5rem;
        margin-bottom: 0.3rem;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.7rem;
        background-color: var(--task-bg-color);
        margin-left: 3px;
        margin-right: 3px;
        margin-top: 3px;
    }

    .task-item .task-title {
        color: #ffffff;
        display: flex;
        align-items: center;
        /* Align icon and text vertically */
        gap: 8px;
        /* Space between icon and text */
        font-size: 18px;
        /* Adjust font size */
        font-weight: 600;
        /* Darker text for better readability */
        margin-bottom: 8px;
        /* Add space below the title */
    }

    .task-item .details {
        display: flex;
        gap: 0.75rem;
        align-items: flex-end;
        margin-top: 0.5rem;
        font-size: 0.8rem;
        color: #e0e0e0;
        height: 15px; /* Set a fixed height */
        overflow: visible; /* Ensure overflow is not hidden */
        position: relative;
    }

    .task-item .details .separator {
        width: 1px;
        height: 0.9rem;
        background-color: #e0e0e0;
        bottom: 10px;
    }

    .task-item.one-time {
        background-color: rgb(55, 92, 172);
    }

    .task-item.repetitive {
        background-color: rgb(114, 31, 80);
    }

    .badges-container {
        display: flex;
        flex-direction: column;
        gap: 8px; /* Space between badges */
        margin-bottom: 0; /* Remove bottom margin */
        justify-content: flex-end; /* Align badges to the bottom */
        margin-left: auto;
        overflow: visible; /* Allow badges to grow upwards */
        position: absolute; /* Position relative to .details */
        bottom: 0; /* Align to the bottom of .details */
        right: 0; /* Align to the right of .details */
    }

    .badge {
        font-size: 0.625rem;
        padding: 0.2rem 0.4rem;
        border-radius: 4px;
        font-weight: 500;
        margin-left: auto;
        margin-top: auto;
    }

    .category-badge {
        color: #3d3d3d; /* Dark teal for text */
        font-size: 0.625rem;
        padding: 0.2rem 0.4rem;
        border-radius: 4px;
        font-weight: 500;
        margin-left: auto;
        margin-top: auto;
    }

    .badge.Low {
        background-color: #228B22; /* Darker Green */
        color: #ffffff;
    }

    .badge.Medium {
        background-color: #FFD700; /* Darker Yellow/Gold */
        color: #000000; /* Black text for better contrast */
    }

    .badge.High {
        background-color: #FF8C00; /* Darker Orange/Dark Goldenrod */
        color: #ffffff;
    }

    .badge.Critical {
        background-color: #DC143C; /* Darker Red/Crimson */
        color: #ffffff;
    }

    .badge.Urgent {
        background-color: #8B0000; /* Very Dark Red/Dark Red */
        color: #ffffff;
    }

    .dropzone {
        background-color: #e8f0fe;
    }

    .tasks, .schedule {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
    }

    .schedule {
        height: calc(100vh - 40px); /* Full height minus padding */
        width: 100%;
    }

    .tasks {
        height: calc(100vh - 40px); /* Full height minus padding */
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .tasks > div {
        flex: 1;
    }
    .container-x {
        height: calc(100dvh - 100px);
    }

    .schedule .dropzone{
        height: calc(100vh - 300px);
    }

    .dropdwon-date {
        min-width: 120px; /* Ensures the dropdown has a fixed minimum width */
    }

    #selectedDateDisplay {
        white-space: nowrap; /* Prevents text from wrapping */
        overflow: hidden; /* Ensures it doesnâ€™t break layout */
        text-overflow: ellipsis; /* Adds '...' if text is too long */
        max-width: 200px; /* Adjust as needed */
        display: inline-block;
    }

    .time-slots {
        height: calc(100vh - 300px);
    }
    .time-slot {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        border-bottom: 1px solid #eee;
        padding: 5px;
        font-size: 0.8rem;
    }

</style>
</head>
<body>
<div class="container-x p-1">
    <div class="row h-100 g-2">
        <!-- Schedule Section (Left) -->
        <div class="col-8 h-100 d-flex">
            <div class="schedule h-100 d-flex flex-column">
                <div class="d-flex align-items-center justify-content-between mb-3">
                    <h5 class="mb-0">Task Scheduler</h5>
                    <div class="d-flex align-items-center">
                        <div class="ms-3">
                            <span>For&nbsp;</span>
                        </div>
                        <select class="form-select dropdwon-date" id="dateSelector">
                            <option value="today">Today</option>
                            <option value="tomorrow">Tomorrow</option>
                        </select>
                        <div class="ms-3">
                            <span id="selectedDateDisplay"></span>
                        </div>
                    </div>
                </div>
                <div class="d-flex flex-grow-1 border-top">
                    <div class="time-column" style="width: 80px; overflow-y: auto; margin-top: 3px;">
                        <div id="time-slots">
                            </div>
                    </div>
                    <ul id="schedule-list" class="task-list dropzone flex-grow-1" data-type="schedule" style="overflow-y: auto;"></ul>
                </div>
                <div class="d-flex gap-3">
                    {% csrf_token %}
                    <button class="btn btn-primary" id="saveButton" type="submit">Save</button>
                    <button class="btn btn-outline-secondary me-2" id="cancelButton">Cancel</button>
                </div>
            </div>
        </div>
        
        

        <!-- Tasks Section (Right) -->
        <div class="col-4 h-100">
            <div class="tasks h-100">
                <div>
                    <h5>One-time Tasks</h5>
                    <ul id="one-time-tasks" class="task-list" data-type="onetime">
                        <li class="task-item" draggable="true" data-id="1" data-item-type="onetime">Task A</li>
                        <li class="task-item" draggable="true" data-id="2" data-item-type="onetime">Task B</li>
                    </ul>
                </div>
                <div>
                    <h5>Repetitive Tasks</h5>
                    <ul id="repetitive-tasks" class="task-list" data-type="repetitive">
                        <li class="task-item" draggable="true" data-id="3" data-item-type="repetitive">Task X</li>
                        <li class="task-item" draggable="true" data-id="4" data-item-type="repetitive">Task Y</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Task Detail Overlay -->
<div class="overlay" id="overlay" style="display: none;"></div>
<div class="task-detail" id="taskDetail" style="display: none;">
</div>

<script>
// ----------------------------adding new scripts above------------------
$(document).ready(function () {
    // URL to fetch tasks (Django URL name: get_sch_tasks)
    const task_url = "{% url 'get_sch_tasks' %}";
    const routine_url = "{% url 'routine_view' %}";


    function formatDate1(date) {
        const options = { weekday: 'long', year: 'numeric', month: 'short', day: 'numeric' };
        return date.toLocaleDateString('en-US', options);
    }

    // Function to format date
    function formatDate(dateString) {
    const date = new Date(dateString);
    
    // Define short month names
    const shortMonth = date.toLocaleString('en-US', { month: 'short' });

    // Extract day and year
    const day = date.getDate();
    const year = date.getFullYear();

    return `${day}-${shortMonth}-${year}`;
    }

    // Function to create a separator
    function createSeparator() {
      const separator = document.createElement('div');
      separator.className = 'separator';
      return separator;
    }

    function updateDateDisplay() {
        const dateSelector = document.getElementById('dateSelector');
        const dateDisplay = document.getElementById('selectedDateDisplay');
        let selectedDate = new Date();

        if (dateSelector.value === "tomorrow") {
            selectedDate.setDate(selectedDate.getDate() + 1);
            fetchRoutine(false);
            fetchTasks(false);
        } else {
            fetchRoutine(true);
            fetchTasks(true);
        }

        dateDisplay.textContent = formatDate1(selectedDate);
    }

    // Initial date display
    updateDateDisplay();

    // Update date display on dropdown change
    document.getElementById('dateSelector').addEventListener('change', updateDateDisplay);

    // Function to get priority label based on priority value
    function getPriorityLabel(priority) {
        switch (priority) {
            case 5:
                return "Urgent";
            case 4:
                return "Critical";
            case 3:
                return "High";
            case 2:
                return "Medium";
            case 1:
                return "Low";
            default:
                return "Unknown";
        }
    }

    // Global array to store all tasks
    let allTasks = [];


    // Fetch routine using AJAX
    function fetchRoutine(paramValue) {
        $.ajax({
            url: routine_url,
            method: "GET",
            data: { param: paramValue }, // Pass param value dynamically
            dataType: "json",
            success: function (data) {
                // Clear existing items in the schedule list
                $("#schedule-list").empty();
                $("#time-slots").empty();

                // Check if the response contains tasks
                if (data !==3 && data.tasks && data.tasks.length > 0) {
                    // Loop through the tasks and populate the schedule list
                    allTasks = [...data.tasks];
                    data.tasks.forEach(function (task) {
                        // Create a task item with necessary attributes
                        const taskItem = $("<li></li>")
                            .addClass("task-item")
                            .attr("draggable", "true")
                            .attr("data-id", task.id) // Use task_id from the task
                            .attr("data-item-type", task.is_repetitive ? "repetitive" : "onetime")
                            .addClass(task.is_repetitive ? "repetitive" : "one-time");

                        // Task Title with Icon
                        const title = document.createElement('h4');
                        title.className = 'task-title'; // Add a class for styling
                        title.innerHTML = `
                            <span class="title-icon"><i class="bi bi-card-heading"></i></span>
                            <span class="title-text">${task.title}</span>
                        `;

                        // Task Details Container
                        const details = document.createElement('div');
                        details.className = 'details';

                        // Duration with Icon
                        const duration = document.createElement('span');
                        duration.innerHTML = `<i class="bi bi-clock"></i> ${formatDuration(task.duration)}`; // Icon for duration

                        // Due Date with Icon
                        let dueDate = null;
                        if (task.is_repetitive) {
                            dueDate = document.createElement('span');
                            dueDate.innerHTML = `<i class="bi bi-calendar-event"></i> ${task.frequency_interval === 1 ? 'Repeats everyday' : `Repeats in every ${task.frequency_interval ? task.frequency_interval : 'Undefined'} days`}`; // Icon for repetitive tasks
                        } else {
                            dueDate = document.createElement('span');
                            dueDate.innerHTML = `<i class="bi bi-calendar-event"></i> Due: ${formatDate(task.due_date)} - ${task.due_time ? formatTime(task.due_time) : 'anytime'}`; // Icon for due date
                        }

                        // Append elements to details
                        details.appendChild(duration);
                        details.appendChild(createSeparator());
                        details.appendChild(dueDate);

                        // Badges Container (for category and priority)
                        const badgesContainer = document.createElement('div');
                        badgesContainer.className = 'badges-container';

                        // Category Badge with Icon
                        const categoryBadge = document.createElement('span');
                        categoryBadge.className = `badge category-badge`;
                        categoryBadge.innerHTML = `<i class="bi bi-tag"></i> ${task.category ? task.category : 'Uncategorized'}`; // Icon for category
                        // Check if task.color exists and apply it as background color
                        if (task.color) {
                            categoryBadge.style.backgroundColor = task.color;
                        }

                        // Priority Badge with Icon
                        const priorityBadge = document.createElement('span');
                        priorityBadge.className = `badge ${getPriorityLabel(task.priority)}`;
                        priorityBadge.innerHTML = `<i class="bi bi-exclamation-circle"></i> ${getPriorityLabel(task.priority)} Priority`; // Icon for priority

                        // Append badges to the badges container
                        badgesContainer.appendChild(categoryBadge);
                        badgesContainer.appendChild(priorityBadge);
                        details.appendChild(badgesContainer);

                        // Append both lines to the task item
                        taskItem.append(title);
                        taskItem.append(details);

                        // Append the task item to the schedule list
                        $("#schedule-list").append(taskItem);

                        // Attach double-click event listener to the task item
                        taskItem.on("dblclick", function () {
                            showTaskDetail(task.id); // Use task_id to show details
                        });
                    });
                    // Call updateTimeSlots to generate time slots after adding tasks
                    updateTimeSlots();
                } else {
                    showMessage('No tasks added!', 'info');
                }
            },
            error: function (xhr, status, error) {
                console.error("Error fetching routine:", error);
            }
        });
    }

    // Fetch tasks using AJAX
    function fetchTasks(paramValue) {
        $.ajax({
            url: task_url,
            method: "GET",
            data: { param: paramValue }, // Pass param value dynamically
            dataType: "json",
            success: function (data) {
                // Clear existing items in the lists
                $("#one-time-tasks").empty();
                $("#repetitive-tasks").empty();

                // Store tasks in the global array
                allTasks = [...data];

                // Sort tasks by priority (5 at the top, 1 at the bottom)
                data.sort((a, b) => b.priority - a.priority);

                // Loop through the sorted tasks and populate the lists
                data.forEach(function (task) {
                    // Check if the task.id exists in the #schedule-list
                    const isTaskInScheduleList = $(`#schedule-list [data-id="${task.id}"]`).length > 0;

                    // If the task is in the schedule list, skip appending it
                    if (isTaskInScheduleList) {
                        return; // Skip this iteration
                    }

                    // Create a task item with necessary attributes
                    const taskItem = $("<li></li>")
                        .addClass("task-item")
                        .attr("draggable", "true")
                        .attr("data-id", task.id)
                        .attr("data-item-type", task.is_repetitive ? "repetitive" : "onetime")
                        .addClass(task.is_repetitive ? "repetitive" : "one-time");

                    // Task Title with Icon
                    const title = document.createElement('h4');
                    title.className = 'task-title'; // Add a class for styling
                    title.innerHTML = `
                        <span class="title-icon"><i class="bi bi-card-heading"></i></span>
                        <span class="title-text">${task.title}</span>
                    `;

                    // Task Details Container
                    const details = document.createElement('div');
                    details.className = 'details';

                    // Duration with Icon
                    const duration = document.createElement('span');
                    duration.innerHTML = `<i class="bi bi-clock"></i> ${formatDuration(task.duration)}`; // Icon for duration

                    // Due Date with Icon
                    let dueDate = null;
                    if (task.is_repetitive) {
                        dueDate = document.createElement('span');
                        dueDate.innerHTML = `<i class="bi bi-calendar-event"></i> ${task.frequency_interval === 1 ? 'Repeats everyday' : `Repeats in every ${task.frequency_interval ? task.frequency_interval : 'Undefined'} days`}`; // Icon for repetitive tasks
                    } else {
                        dueDate = document.createElement('span');
                        dueDate.innerHTML = `<i class="bi bi-calendar-event"></i> Due: ${formatDate(task.due_date)} - ${task.due_time ? formatTime(task.due_time) : 'anytime'}`; // Icon for due date
                    }

                    // Append elements to details
                    details.appendChild(duration);
                    details.appendChild(createSeparator());
                    details.appendChild(dueDate);

                    // Badges Container (for category and priority)
                    const badgesContainer = document.createElement('div');
                    badgesContainer.className = 'badges-container';

                    // Category Badge with Icon
                    const categoryBadge = document.createElement('span');
                    categoryBadge.className = `badge category-badge`;
                    categoryBadge.innerHTML = `<i class="bi bi-tag"></i> ${task.category ? task.category : 'Uncategorized'}`; // Icon for category
                    // Check if task.color exists and apply it as background color
                    if (task.color) {
                        categoryBadge.style.backgroundColor = task.color;
                    }


                    // Priority Badge with Icon
                    const priorityBadge = document.createElement('span');
                    priorityBadge.className = `badge ${getPriorityLabel(task.priority)}`;
                    priorityBadge.innerHTML = `<i class="bi bi-exclamation-circle"></i> ${getPriorityLabel(task.priority)} Priority`; // Icon for priority

                    // Append badges to the badges container
                    badgesContainer.appendChild(categoryBadge);
                    badgesContainer.appendChild(priorityBadge);

                    details.appendChild(badgesContainer);

                    // Append both lines to the task item
                    taskItem.append(title);
                    taskItem.append(details);
                    // taskItem.append(badgesContainer); // Add badges container to the bottom-right

                    // Append to the appropriate list based on is_repetitive
                    if (task.is_repetitive) {
                        $("#repetitive-tasks").append(taskItem);
                    } else {
                        $("#one-time-tasks").append(taskItem);
                    }

                    // Attach double-click event listener to the task item
                    taskItem.on("dblclick", function () {
                        showTaskDetail(task.id);
                    });
                });
            },
            error: function (xhr, status, error) {
                console.error("Error fetching tasks:", error);
            }
        });
    }

    // POST request to save the schedule

    document.getElementById('saveButton').addEventListener('click', function(event) {
        event.preventDefault(); // Prevent default form submission

        const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
        const scheduleListItems = document.querySelectorAll('#schedule-list li');
        const selectedDate = document.getElementById('dateSelector').value;
        const today = new Date();
        let forDate;

        // Determine the for_date based on the selected date
        if (selectedDate === 'today') {
            forDate = today.toISOString().split('T')[0]; // Format: YYYY-MM-DD
        } else if (selectedDate === 'tomorrow') {
            const tomorrow = new Date(today);
            tomorrow.setDate(today.getDate() + 1);
            forDate = tomorrow.toISOString().split('T')[0];
        } else {
            console.error('Invalid date selection.');
            return;
        }

        // Prepare tasks data
        const tasks = Array.from(scheduleListItems).map(item => {
            const taskId = parseInt(item.getAttribute('data-id'));
            const task = allTasks.find(t => t.id === taskId); 
            if (task) {
                return {
                    start_time: task.start_time,
                    duration: task.duration,
                    id: task.id, 
                    title: task.title,
                    category: task.category,
                    priority: task.priority,
                    is_repetitive: task.is_repetitive,
                    frequency_interval: task.frequency_interval,
                    due_date: task.due_date,
                    due_time: task.due_time,
                    color: task.color,
                };
            } else {
                console.error(`Task with ID ${taskId} not found in allTasks.`);
                return null;
            }
        }).filter(task => task !== null); // Filter out null tasks

        // Check if there are valid tasks to save
        if (tasks.length === 0) {
            showMessage('No tasks to save', 'error');
            return;
        }

        // Send data to the backend
        const post_url = "{% url 'routine_save' %}";
        fetch(post_url, { // Replace with your actual API endpoint
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken,
            },
            body: JSON.stringify({
                for_date: forDate,
                tasks: tasks,
            }),
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            showMessage(data.message, 'success');
        })
        .catch(error => {
            console.error('Error saving routine:', error);
            alert('Failed to save routine. Please try again.'); // Provide user feedback
        });
    });

    // ENDING OF NEW FUNCTIONS

    // Function to show task detail
    async function showTaskDetail(taskId) {
      try {
        // const baseUrl = window.location.origin;
        const response = await fetch(`/api/task-detail/${taskId}/`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            // Add authentication token if required
            // 'Authorization': `Bearer ${localStorage.getItem('access_token')}`
          },
        });

        if (!response.ok) {
          throw new Error('Failed to fetch task details');
        }

        const taskDetail = await response.json();
        renderTaskDetail(taskDetail);
      } catch (error) {
        console.error('Error fetching task details:', error);
      }
    }

    function getCSRFToken() {
      return document.cookie
        .split('; ')
        .find(row => row.startsWith('csrftoken='))
        ?.split('=')[1];
    }

    // Function to format time
    function formatTime(timeString) {
      const time = new Date(`1970-01-01T${timeString}`);
      return time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });
    }

    function formatDuration(minutes) {
      if (minutes === null || minutes === undefined) {
        return "N/A"; // Handle cases where duration is not available
      }

      const hours = Math.floor(minutes / 60);
      const remainingMinutes = minutes % 60;

      const formattedHours = String(hours).padStart(2, '0');
      const formattedMinutes = String(remainingMinutes).padStart(2, '0');
      if (formattedHours === `00`) {
        return `${formattedMinutes} Minutes`;
      } else {
        return `${formattedHours} hr ${formattedMinutes} min`;
      }

    }

    // Function to delete task
    async function delTask(taskId) {
      const csrftoken = getCSRFToken();
      try {
        const response = await fetch(`/api/task-delete/${taskId}/`, {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken,  // Add CSRF token header
            // Add authentication token if required
            // 'Authorization': `Bearer ${localStorage.getItem('access_token')}`
          },
        });

        if (!response.ok) {
          throw new Error('Failed to delete!');
        }

        const res = await response.json();
        showMessage(res.message, 'successs')
        const wardiv = document.querySelector('.warningdiv')
        const overlay = document.getElementById('overlay'); 
        if (wardiv) {
          wardiv.remove(); // Completely deletes the element
        }
        overlay.style.display = 'none';
        updateDateDisplay();

      } catch (error) {
        showMessage(error, 'error')
      }
    }

    // Function to render task detail
    function renderTaskDetail(task) {
      const overlay = document.getElementById('overlay');
      const taskDetailContainer = document.getElementById('taskDetail');

      // Clear existing content
      taskDetailContainer.innerHTML = '';

      // Create and append elements
      const title = document.createElement('h4');
      title.innerHTML = `<i class="bi bi-card-heading"></i> ${task.title}`; // Icon for title

      const duration = document.createElement('p');
      duration.innerHTML = `<i class="bi bi-clock"></i> ${formatDuration(task.duration)}`; // Icon for duration

      const category = document.createElement('p');
      category.innerHTML = `<i class="bi bi-tag"></i> Category: ${task.category ? task.category : 'Uncategorized'}`; // Icon for category

      const priority = document.createElement('p');
      priority.innerHTML = `<i class="bi bi-exclamation-circle"></i> Priority: ${getPriorityLabel(task.priority)}`; // Icon for priority

      const dueDate = document.createElement('p');
      if (task.is_repetitive) {
        dueDate.innerHTML = `<i class="bi bi-calendar-event"></i> Next Due: ${formatDate(task.due_date)} <br>-->Frequency: ${task.frequency_interval === 1 ? 'Daily' : `Repeats in every ${task.frequency_interval ? task.frequency_interval : 'Undefined'} days`}`; // Icon for repetitive tasks
      } else {
        dueDate.innerHTML = `<i class="bi bi-calendar-event"></i> Due: ${formatDate(task.due_date)}<br>-->At ${task.due_time ? formatTime(task.due_time) : 'anytime'}`; // Icon for due date
      }

      const description = document.createElement('p');
      description.innerHTML = `<i class="bi bi-card-text"></i> Description: ${task.description || 'No description'}`; // Icon for description

      // Buttons
      const okayButton = document.createElement('button');
      okayButton.className = 'btn btn-primary';
      okayButton.innerHTML = `<i class="bi bi-check-circle"></i> Okay`; // Icon for Okay button
      okayButton.onclick = closeTaskDetail;
      okayButton.style.marginRight = '10px'; // Add right margin

      const editButton = document.createElement('button');
      editButton.className = 'btn btn-outline-secondary';
      editButton.innerHTML = `<i class="bi bi-pencil"></i> Edit`; // Icon for Edit button
      editButton.style.marginRight = '10px';

      const editurl = `/task/edit_task/${task.id}/`

      const deleteButton = document.createElement('button');
      deleteButton.className = 'btn btn-danger';
      deleteButton.innerHTML = `<i class="bi bi-trash"></i> Delete`;

      deleteButton.addEventListener('click', function () {
        const taskDetail = document.querySelector('.task-detail');
        const warningDiv = document.createElement('div');
        const bdy = document.getElementById('new-content');
        warningDiv.className = 'warningdiv';
        warningDiv.innerHTML = `
            <div class="text-center">
                <h5 class="mb-3">Deleting Task: <strong>${task.title}</strong></h5>
                <p class="mb-2">Are you sure you want to delete this task?</p>
                <p class="text-muted small mb-4">*This action can't be undone.</p>
                <div class="d-flex justify-content-center">
                    <button class="btn btn-danger yes-button me-3">Delete</button>
                    <button class="btn btn-outline-secondary no-button">Cancel</button>
                </div>
            </div>
        `;

        taskDetail.style.display = 'none';
        bdy.appendChild(warningDiv);

        const noButton = warningDiv.querySelector('.no-button');
        noButton.addEventListener('click', function () {
          warningDiv.style.display = 'none';
          taskDetail.style.display = 'block';
          warningDiv.remove();
        });

        const yesButton = warningDiv.querySelector('.yes-button');
        yesButton.onclick = () => delTask(task.id);
      });

      editButton.addEventListener('click', function () {
        $(document).trigger('contentUpdated', [editurl, '#new-content', true]);
      });

      // Append elements to task detail container
      taskDetailContainer.appendChild(title);
      taskDetailContainer.appendChild(duration);
      taskDetailContainer.appendChild(category);
      taskDetailContainer.appendChild(priority);
      taskDetailContainer.appendChild(dueDate);
      taskDetailContainer.appendChild(description);
      taskDetailContainer.appendChild(okayButton);
      taskDetailContainer.appendChild(editButton);
      taskDetailContainer.appendChild(deleteButton);

      // Show overlay and task detail
      overlay.style.display = 'block';
      taskDetailContainer.style.display = 'block';
    }

    // Function to close task detail
    function closeTaskDetail() {
      const overlay = document.getElementById('overlay');
      const taskDetailContainer = document.getElementById('taskDetail');

      // Hide overlay and task detail
      overlay.style.display = 'none';
      taskDetailContainer.style.display = 'none';
    }

    const dropzones = document.querySelectorAll(".task-list");

    dropzones.forEach(zone => {
        zone.addEventListener("dragover", function (event) {
            event.preventDefault();
            const dragging = document.querySelector(".dragging");
            if (!dragging) return; // Prevent errors if no item is being dragged

            const draggingType = dragging.dataset.itemType;
            const destinationType = zone.dataset.type;

            // Allow dropping only if:
            // 1. The destination is the schedule list, or
            // 2. The destination matches the item's type (onetime or repetitive)
            if (destinationType === "schedule" || destinationType === draggingType) {
                const afterElement = getDragAfterElement(zone, event.clientY);
                if (afterElement == null) {
                    zone.appendChild(dragging);
                } else {
                    zone.insertBefore(dragging, afterElement);
                }
            } else {
            zone.classList.add("border-danger"); // Add red border for invalid drop
        }
        });

        zone.addEventListener("drop", function (event) {
            event.preventDefault();
            const dragging = document.querySelector(".dragging");
            if (dragging) {
                dragging.classList.remove("dragging");
                dragging.style.opacity = "1"; // Smoothly show the item again
                zone.classList.remove("border-danger");

                if (zone.id === "schedule-list") {
                    updateTimeSlots(); // Update time slots when dropped into schedule
                } else if (zone.id === "one-time-tasks" || zone.id === "repetitive-tasks") {
                    updateTimeSlots(); // Update time slots when removed from schedule
                }
            }
        });

        zone.addEventListener("dragleave", function () {
            zone.classList.remove("over");
            zone.classList.remove("border-danger");
        });
    });

    // Function to make an element draggable
    function makeDraggable(task) {
        task.setAttribute("draggable", "true");

        task.addEventListener("dragstart", function (event) {
            event.dataTransfer.setData("text/plain", event.target.dataset.id);
            event.target.classList.add("dragging");
            setTimeout(() => {
                event.target.style.opacity = "0"; // Hide smoothly on drag
            }, 0);
        });

        task.addEventListener("dragend", function (event) {
            event.target.classList.remove("dragging");
            event.target.style.opacity = "1"; // Fade back in on drop
        });
    }

    // Function to get the correct insertion point in the list
    function getDragAfterElement(zone, y) {
        const draggableElements = [...zone.querySelectorAll(".task-item:not(.dragging)")];

        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - (box.top + box.height / 2);
            return offset < 0 && offset > closest.offset ? { offset, element: child } : closest;
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    // Attach draggable functionality to existing task items
    document.querySelectorAll(".task-item").forEach(makeDraggable);

    // Observe dynamically added tasks
    const observer = new MutationObserver(mutations => {
        mutations.forEach(mutation => {
            mutation.addedNodes.forEach(node => {
                if (node.nodeType === 1 && node.classList.contains("task-item")) {
                    makeDraggable(node); // Make newly added tasks draggable
                }
            });
        });
    });

    // Start observing changes in the task lists
    dropzones.forEach(zone => {
        observer.observe(zone, { childList: true });
    });

    // Function to calculate and update time slots
    function updateTimeSlots() {
        const scheduleList = document.getElementById("schedule-list");
        const timeSlotsContainer = document.getElementById("time-slots");
        timeSlotsContainer.innerHTML = ""; // Clear existing time slots

        let currentTime = new Date();
        currentTime.setHours(6, 0, 0, 0); // Start from 6:00 AM

        scheduleList.querySelectorAll(".task-item").forEach(taskItem => {
            const taskId = taskItem.dataset.id;
            const taskData = getTaskDataById(taskId); // Function to fetch task data
            if (taskData) {
                // Get computed height of the corresponding task-item
                const taskHeight = taskItem.getBoundingClientRect().height;

                const durationMinutes = taskData.duration; // Assuming duration is in minutes
                const endTime = new Date(currentTime.getTime() + durationMinutes * 60000);

                const startTimeString = currentTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
                const endTimeString = endTime.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

                // Add start_time to the task in allTasks array
                const taskIndex = allTasks.findIndex(task => task.id === parseInt(taskId, 10));
                if (taskIndex !== -1) {
                    allTasks[taskIndex].start_time = startTimeString; // Add start_time to the task
                }

                const timeSlotDiv = document.createElement("div");
                timeSlotDiv.classList.add("time-slot");
                timeSlotDiv.style.height = `${taskHeight+4}px`;

                const startTimeSpan = document.createElement("span");
                startTimeSpan.textContent = startTimeString;

                const endTimeSpan = document.createElement("span");
                endTimeSpan.textContent = endTimeString;

                timeSlotDiv.appendChild(startTimeSpan);
                timeSlotDiv.appendChild(endTimeSpan);

                timeSlotsContainer.appendChild(timeSlotDiv);

                currentTime = endTime; // Update current time for the next task
            }
        });
    }

    // Function to fetch task data by ID (now using the global array)
    function getTaskDataById(taskId) {
        return allTasks.find(task => task.id === parseInt(taskId));
    }
});

</script>