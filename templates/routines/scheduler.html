<style>

    /* Firefox Scrollbar Styling */
    #repetitive-tasks,
    #one-time-tasks,
    .scroll-container {
        scrollbar-width: thin; /* "auto" or "thin" */
        scrollbar-color: #888 #f1f1f1; /* thumb and track color */
    }

    /* General Scrollbar Styling (WebKit) */
    #repetitive-tasks::-webkit-scrollbar,
    #one-time-tasks::-webkit-scrollbar,
    .scroll-container::-webkit-scrollbar {
        width: 8px; /* Adjust width as needed */
    }

    #repetitive-tasks::-webkit-scrollbar-track,
    #one-time-tasks::-webkit-scrollbar-track,
    .scroll-container::-webkit-scrollbar-track {
        background: #f1f1f1; /* Light background for the track */
        border-radius: 4px;
    }

    #repetitive-tasks::-webkit-scrollbar-thumb,
    #one-time-tasks::-webkit-scrollbar-thumb,
    .scroll-container::-webkit-scrollbar-thumb {
        background: #888; /* Medium gray for the thumb */
        border-radius: 4px;
    }

    #repetitive-tasks::-webkit-scrollbar-thumb:hover,
    #one-time-tasks::-webkit-scrollbar-thumb:hover,
    .scroll-container::-webkit-scrollbar-thumb:hover {
        background: #555; /* Darker gray on hover */
    }

    .task-detail {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #ffffff;
        padding: 1.5rem;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        z-index: 999;
        font-size: 0.975rem;
        width: 80vw;
        /* Set width to 80% of the viewport width */
        max-width: 500px;
        /* Optional: set a maximum width */
    }

    .overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 998;
    }

    .task-list {
        list-style: none;
        padding: 0;
        min-height: 250px;
        /* border: 2px dashed #ccc; */
        background-color: #88a9ca;
        border: solid 2px #ccc;
        border-radius: 8px;
    }

    #repetitive-tasks, #one-time-tasks {
        overflow-y: auto;
        flex: 1;
        max-height: calc(100dvh - 700px);
    }

    #misc-tasks {
        min-height: 80px; /* Or any smaller height you prefer */
        display: flex; /* Enable flexbox for the list */
        flex-direction: row; /* Arrange items in a row */
        justify-content: space-around; /* optional: align items to the start of the row*/
        align-items: center; /* optional: align items vertically centered*/
        list-style: none; /* Remove default list styling */
    }



    #misc-tasks .task-item:last-child {
        margin-right: 0px; /* remove margin from last item*/
    }

    .task-item {
        padding: 0.5rem;
        margin-bottom: 5px;
        border-radius: 6px;
        cursor: pointer;
        font-size: 0.7rem;
        background-color: var(--task-bg-color);
        margin-left: 3px;
        margin-right: 3px;
        margin-top: 3px;
    }

    .task-item .task-title {
        color: #ffffff;
        display: flex;
        align-items: center;
        /* Align icon and text vertically */
        gap: 8px;
        /* Space between icon and text */
        font-size: 18px;
        /* Adjust font size */
        font-weight: 600;
        /* Darker text for better readability */
        margin-bottom: 8px;
        /* Add space below the title */
    }

    .task-item .details {
        display: flex;
        gap: 0.75rem;
        align-items: center;
        margin-top: 0.5rem;
        font-size: 0.8rem;
        color:  #e0e0e0;
        position: relative;
    }

    .task-item .details .separator {
        width: 1px;
        height: 0.9rem;
        background-color: #e0e0e0;
        bottom: 10px;
    }

    .task-item.one-time {
        background-color: rgb(55, 92, 172);
    }

    .task-item.repetitive {
        background-color: rgb(114, 31, 80);
    }

    .task-item.misc {
        background-color: #1f1f1f;
        white-space: nowrap; /* Prevent text from wrapping */
        width: 100; /* Occupy full width of the container */
        height: 60px; /* Set a fixed height or use min-height */
        padding: 10px; /* Add padding for better spacing */
        box-sizing: border-box; /* Include padding in width/height calculations */
        display: flex; /* Use flexbox for alignment */
        align-items: center; /* Vertically center content */
        justify-content: space-between; /* Space out content */
    }

    .task-item.misc.x {
        width: 100; /* Occupy full width of the container */
    }

    .task-item.misc.y {
        width: 100%; /* Occupy full width of the container */
        min-width: 0;
    }

    .badges-container {
        display: flex;
        flex-direction: column;
        gap: 8px; /* Space between badges */
        margin-bottom: 0; /* Remove bottom margin */
        justify-content: flex-end; /* Align badges to the bottom */
        margin-left: auto;
        overflow: visible; /* Allow badges to grow upwards */
        position: absolute; /* Position relative to .details */
        bottom: 0; /* Align to the bottom of .details */
        right: 0; /* Align to the right of .details */
    }

    .badge {
        font-size: 0.625rem;
        padding: 0.2rem 0.4rem;
        border-radius: 4px;
        font-weight: 500;
        margin-left: auto;
        margin-top: auto;
    }

    .category-badge {
        color: #3d3d3d; /* Dark teal for text */
        font-size: 0.625rem;
        padding: 0.2rem 0.4rem;
        border-radius: 4px;
        font-weight: 500;
        margin-left: auto;
        margin-top: auto;
    }

    .badge.Low {
        background-color: #228B22; /* Darker Green */
        color: #ffffff;
    }

    .badge.Medium {
        background-color: #FFD700; /* Darker Yellow/Gold */
        color: #000000; /* Black text for better contrast */
    }

    .badge.High {
        background-color: #FF8C00; /* Darker Orange/Dark Goldenrod */
        color: #ffffff;
    }

    .badge.Critical {
        background-color: #DC143C; /* Darker Red/Crimson */
        color: #ffffff;
    }

    .badge.Urgent {
        background-color: #8B0000; /* Very Dark Red/Dark Red */
        color: #ffffff;
    }

    .tasks {
        height: 500px;
        /* overflow-y: auto; */
        min-width: 300px;
        overflow-x: hidden;
        /* height: calc(100vh - 40px); */
        display: flex;
        flex-direction: column;
        gap: 1px;
    }

    .tasks > div {
        flex: 1;
        display: flex;
        flex-direction: column;
    }
    .container-x {
        height: calc(100dvh - 100px);
        min-width: 900px;
        /* overflow-x: auto; */
    }

    .schedule .dropzone{
        background-color: #e8f0fe;
        display: flex;
        flex-direction: column;
        flex-grow: 1;
        min-height: 100%;
    }

    .tasks, .schedule {
        background: white;
        padding: 20px;
        border-radius: 8px;
        box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.1);
    }

    .schedule {
        /* height: calc(100vh - 40px);  */
        width: 100%;
        height: 100;

    }

    .dropdwon-date {
        min-width: 120px; /* Ensures the dropdown has a fixed minimum width */
    }

    #selectedDateDisplay {
        white-space: nowrap; /* Prevents text from wrapping */
        overflow: hidden; /* Ensures it doesn’t break layout */
        text-overflow: ellipsis; /* Adds '...' if text is too long */
        max-width: 200px; /* Adjust as needed */
        display: inline-block;
    }

    /* Time slots */
    .time-slots {
        display: flex;
        flex-direction: column;
    }

    .time-slot {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        border-bottom: 2px solid #bbbbbb;
        font-size: 0.8rem;
        margin-top: 2px;
        margin-bottom: 5px;
    }
    /* Container for time-column and schedule-list */
    .scroll-container {
        display: flex;
        flex-grow: 1;
        overflow-y: auto; /* Enable scrolling for the container */
        height: calc(100vh - 260px); /* Adjust based on your layout */
    }

    /* Remove overflow-y from individual elements */
    .time-column, #schedule-list {
        overflow-y: visible; /* Disable individual scrolling */
    }

    .time-column {
        width: 80px;
        margin-top: 3px;
    }

    #schedule-list {
        flex-grow: 1;
    }

</style>
</head>
<body>
<div class="container-x p-1">
    <div class="row h-100 g-2">
        <!-- Schedule Section (Left) -->
        <div class="col-7 h-100 d-flex">
            <div class="schedule h-100 d-flex flex-column">
                <div class="d-flex align-items-center justify-content-between mb-3">
                    <h5 class="mb-0">Task Scheduler</h5>
                    <div class="d-flex align-items-center">
                        <div class="ms-3">
                            <span>For&nbsp;</span>
                        </div>
                        <select class="form-select dropdwon-date" id="dateSelector">
                            <option value="today">Today</option>
                            <option value="tomorrow">Tomorrow</option>
                        </select>
                        <div class="ms-3">
                            <span id="selectedDateDisplay"></span>
                        </div>
                    </div>
                </div>
                <div class="d-flex flex-grow-1 border-top">
                    <div class="scroll-container">
                        <div class="time-column">
                            <div id="time-slots"></div>
                        </div>
                        <ul id="schedule-list" class="task-list dropzone flex-grow-1" data-type="schedule"></ul>
                    </div>
                </div>
                <div class="d-flex gap-3">
                    {% csrf_token %}
                    <button class="btn btn-primary" id="saveButton" type="submit">Save</button>
                    <button class="btn btn-outline-secondary me-2" id="cancelButton">Cancel</button>
                </div>
            </div>
        </div>
        
        

        <!-- Tasks Section (Right) -->
        <div class="col-5 h-100">
            <div class="tasks h-100">
                <div>
                    <p>One-time Tasks</p>
                    <ul id="one-time-tasks" class="task-list" data-type="onetime">
                        <li class="task-item" draggable="true" data-id="1" data-item-type="onetime">Task A</li>
                        <li class="task-item" draggable="true" data-id="2" data-item-type="onetime">Task B</li>
                    </ul>
                </div>
                <div>
                    <p>Repetitive Tasks</p>
                    <ul id="repetitive-tasks" class="task-list" data-type="repetitive">
                        <li class="task-item" draggable="true" data-id="3" data-item-type="repetitive">Task X</li>
                        <li class="task-item" draggable="true" data-id="4" data-item-type="repetitive">Task Y</li>
                    </ul>
                </div>
                <div>
                    <p>Misc</p>
                    <ul id="misc-tasks" class="task-list" data-type="misc">
                        <li class="task-item misc y" draggable="true" data-id="1" data-item-type="misc" data-src="msc">
                            <h4 class="task-title">
                                <span class="title-icon"><i class="bi bi-card-heading"></i></span>
                                <span class="title-text">Time Gap</span>
                            </h4>
                            <div class="details">
                                <span><i class="bi bi-clock"></i> 30 Minutes</span>
                            </div>
                        </li>
                        <li class="task-item misc y" draggable="true" data-id="2" data-item-type="misc" data-src="msc">Relax</li>
                        <li class="task-item misc y" draggable="true" data-id="3" data-item-type="misc" data-src="msc">Sleep</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Task Detail Overlay -->
<div class="overlay" id="overlay" style="display: none;"></div>
<div class="task-detail" id="taskDetail" style="display: none;">
</div>


<script>
// ----------------------------adding new scripts above------------------
$(document).ready(function () {
    // URL to fetch tasks (Django URL name: get_sch_tasks)
    const task_url = "{% url 'get_sch_tasks' %}";
    const routine_url = "{% url 'routine_view' %}";
    let unsavedChanges = false;
    let day = true;

    // Global array to store all tasks
    let allTasks = [];
    let allTskRtn = [];
    let allMscRtn = [];
    let allMisc = [
        {
            id: 1,
            title: "Break",
            duration: 30 // Duration in minutes
        },
        {
            id: 2,
            title: "Relax",
            duration: 20 // Duration in minutes
        },
        {
            id: 3,
            title: "Sleep",
            duration: 180 // Duration in minutes
        }
    ];

    let routine_date;


    function formatDate1(date) {
        const options = { weekday: 'long', year: 'numeric', month: 'short', day: 'numeric' };
        return date.toLocaleDateString('en-US', options);
    }

    // Function to format date
    function formatDate(dateString) {
    const date = new Date(dateString);
    
    // Define short month names
    const shortMonth = date.toLocaleString('en-US', { month: 'short' });

    // Extract day and year
    const day = date.getDate();
    const year = date.getFullYear();

    return `${day}-${shortMonth}-${year}`;
    }

    // Function to create a separator
    function createSeparator() {
      const separator = document.createElement('div');
      separator.className = 'separator';
      return separator;
    }

    function updateDateDisplay() {
        const dateSelector = document.getElementById('dateSelector');
        const dateDisplay = document.getElementById('selectedDateDisplay');
        let selectedDate = new Date();

        // Using the functions in sequence
        if (dateSelector.value === "tomorrow") {
            selectedDate.setDate(selectedDate.getDate() + 1);
            day = false;

            // Fetch routine first, then fetch tasks
            fetchRoutine(day, function () {
                fetchTasks(day);
            });

            unsavedChanges = false;
        } else {
            day = true;

            // Fetch routine first, then fetch tasks
            fetchRoutine(day, function () {
                fetchTasks(day);
            });

            unsavedChanges = false;
        }

        dateDisplay.textContent = formatDate1(selectedDate);
        makeMiscTasks();
    }

    function getDateDifference(value, givenDate) {
        // Convert the given date to a Date object
        const date = new Date(givenDate);
        const today = new Date();
        const tomorrow = new Date();
        tomorrow.setDate(today.getDate() + 1);

        // Set time to midnight for accurate day comparison
        today.setHours(0, 0, 0, 0);
        tomorrow.setHours(0, 0, 0, 0);
        date.setHours(0, 0, 0, 0);

        // Calculate the difference in days
        const diffTime = date - (value === "today" ? today : tomorrow);
        const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

        if (diffDays === 0) {
            return `(${value.charAt(0).toUpperCase() + value.slice(1)})`;
        } else {
            return `(in ${diffDays} day${diffDays !== 1 ? 's' : ''} from ${value})`;
        }
    }

    // Initial date display
    updateDateDisplay();

    // Update date display on dropdown change
    document.getElementById('dateSelector').addEventListener('change', updateDateDisplay);

    // Function to get priority label based on priority value
    function getPriorityLabel(priority) {
        switch (priority) {
            case 5:
                return "Urgent";
            case 4:
                return "Critical";
            case 3:
                return "High";
            case 2:
                return "Medium";
            case 1:
                return "Low";
            default:
                return "Unknown";
        }
    }


    function createTaskListItem(task, source) {
        // Create a task item with necessary attributes
        const taskItem = $("<li></li>")
            .addClass("task-item")
            .attr("draggable", "true")
            .attr("data-id", task.id) // Use task_id from the task
            .attr("data-item-type", task.is_repetitive ? "repetitive" : "onetime")
            .attr("data-src", source) // Add the data-src attribute
            .addClass(task.is_repetitive ? "repetitive" : "one-time");

        // Task Title with Icon
        const title = document.createElement('h4');
        title.className = 'task-title'; // Add a class for styling
        title.innerHTML = `
            <span class="title-icon"><i class="bi bi-card-heading"></i></span>
            <span class="title-text">${task.title}</span>
        `;

        // Task Details Container
        const details = document.createElement('div');
        details.className = 'details';

        // Duration with Icon
        const duration = document.createElement('span');
        duration.innerHTML = `<i class="bi bi-clock"></i> ${formatDuration(task.duration)}`; // Icon for duration

        // Due Date with Icon
        let dueDate = null;
        if (task.is_repetitive) {
            dueDate = document.createElement('span');
            dueDate.innerHTML = `<i class="bi bi-calendar-event"></i> ${task.frequency_interval === 1 ? 'Repeats everyday' : `Repeats in every ${task.frequency_interval ? task.frequency_interval : 'Undefined'} days`}`; // Icon for repetitive tasks
        } else {
            dateValue = document.getElementById('dateSelector');
            dueDate = document.createElement('span');
            dueDate.innerHTML = `<i class="bi bi-calendar-event"></i> Due: ${formatDate(task.due_date)} - ${task.due_time ? formatTime(task.due_time) : 'anytime'} | ${getDateDifference(dateValue.value, task.due_date)}`; // Icon for due date
        }

        // Append elements to details
        details.appendChild(duration);
        details.appendChild(createSeparator());
        details.appendChild(dueDate);

        // Badges Container (for category and priority)
        const badgesContainer = document.createElement('div');
        badgesContainer.className = 'badges-container';

        // Category Badge with Icon
        const categoryBadge = document.createElement('span');
        categoryBadge.className = `badge category-badge`;
        categoryBadge.innerHTML = `<i class="bi bi-tag"></i> ${task.category ? task.category : 'Uncategorized'}`; // Icon for category
        // Check if task.color exists and apply it as background color
        if (task.color) {
            categoryBadge.style.backgroundColor = task.color;
        }

        // Priority Badge with Icon
        const priorityBadge = document.createElement('span');
        priorityBadge.className = `badge ${getPriorityLabel(task.priority)}`;
        priorityBadge.innerHTML = `<i class="bi bi-exclamation-circle"></i> ${getPriorityLabel(task.priority)} Priority`; // Icon for priority

        // Append badges to the badges container
        badgesContainer.appendChild(categoryBadge);
        badgesContainer.appendChild(priorityBadge);
        details.appendChild(badgesContainer);

        // Append both lines to the task item
        taskItem.append(title);
        taskItem.append(details);

        return taskItem;
    }

    // Fetch routine using AJAX
    function fetchRoutine(paramValue, callback) {
        $.ajax({
            url: routine_url,
            method: "GET",
            data: { param: paramValue }, // Pass param value dynamically
            dataType: "json",
            success: function (data) {
                // Clear existing items in the schedule list
                $("#schedule-list").empty();
                $("#time-slots").empty();
                allTskRtn = [];
                allMscRtn = [];

                // Check if the response contains tasks
                if (data !== 3 && data.tasks && data.tasks.length > 0) {
                    // Loop through the tasks and populate the schedule list
                    routine_date = data.updated_at;
                    data.tasks.forEach(function (task) {
                        let taskItem;
                        let src;
                        if (task.is_task) {
                            allTskRtn.push(task);
                            src = 'rtn';
                            taskItem = createTaskListItem(task, "rtn"); // Call the function
                        } else {
                            allMscRtn.push(task);
                            src = 'msc';
                            taskItem = createMiscTask(task, task.id, "x");
                        }

                        // Append the task item to the schedule list
                        $("#schedule-list").append(taskItem);

                        // Attach double-click event listener to the task item
                        taskItem.on("click", function () {
                            showTaskDetail(task.id, src, taskItem[0]); // Use task_id to show details
                        });
                    });
                    // Call updateTimeSlots to generate time slots after adding tasks
                    updateTimeSlots();
                } else {
                    showMessage('No tasks added!', 'info');
                }

                // Invoke the callback function after `fetchRoutine` completes
                if (callback) {
                    callback();
                }
            },
            error: function (xhr, status, error) {
                console.error("Error fetching routine:", error);
            }
        });
    }

    // Fetch tasks using AJAX
    function fetchTasks(paramValue) {
        $.ajax({
            url: task_url,
            method: "GET",
            data: { param: paramValue }, // Pass param value dynamically
            dataType: "json",
            success: function (data) {
                // Clear existing items in the lists
                $("#one-time-tasks").empty();
                $("#repetitive-tasks").empty();

                // Store tasks in the global array
                allTasks = [...data];

                // Sort tasks by priority (5 at the top, 1 at the bottom)
                data.sort((a, b) => b.priority - a.priority);

                // Loop through the sorted tasks and populate the lists
                data.forEach(function (task) {

                    // Define the keys to compare
                    const keysToCompare = ['duration', 'category', 'priority', 'is_repetitive', 'frequency_interval', 'due_date', 'due_time', 'color'];

                    // Find the task in allTskRtn with the same id
                    const taskInAllTskRtn = allTskRtn.find(t => t.id === task.id);

                    // If the task is found in allTskRtn
                    if (taskInAllTskRtn) {
                        // Check if all the specified keys have the same values in both task and taskInAllTskRtn
                        const areValuesSame = keysToCompare.every(key => task[key] === taskInAllTskRtn[key]);

                        // If all values are the same, return
                        if (areValuesSame) {
                            return; // Skip this iteration
                        }
                    }

                    const taskItem = createTaskListItem(task, "tsk");

                    // Append to the appropriate list based on is_repetitive
                    if (task.is_repetitive) {
                        $("#repetitive-tasks").append(taskItem);
                    } else {
                        $("#one-time-tasks").append(taskItem);
                    }

                    // Attach double-click event listener to the task item
                    taskItem.on("click", function () {
                        showTaskDetail(task.id, 'tsk', taskItem[0]);
                    });
                });
            },
            error: function (xhr, status, error) {
                console.error("Error fetching tasks:", error);
            }
        });
    }

    function makeMiscTasks(){
        $("#misc-tasks").empty();
        allMisc.forEach(function (task) {
            const id = task.id;
            const taskItem = createMiscTask(task, id, "y");
            $("#misc-tasks").append(taskItem);
            taskItem.on("click", function () {
                showTaskDetail(task.id, 'msc', taskItem[0]);
            })
        })
    }

    // POST request to save the schedule

    document.getElementById('saveButton').addEventListener('click', function(event) {
        event.preventDefault(); // Prevent default form submission

        const csrfToken = document.querySelector('[name=csrfmiddlewaretoken]').value;
        const scheduleListItems = document.querySelectorAll('#schedule-list li');
        const selectedDate = document.getElementById('dateSelector').value;
        const today = new Date();
        let forDate;

        // Determine the for_date based on the selected date
        if (selectedDate === 'today') {
            forDate = today.toISOString().split('T')[0]; // Format: YYYY-MM-DD
        } else if (selectedDate === 'tomorrow') {
            const tomorrow = new Date(today);
            tomorrow.setDate(today.getDate() + 1);
            forDate = tomorrow.toISOString().split('T')[0];
        } else {
            console.error('Invalid date selection.');
            return;
        }

        // Prepare tasks data
        const tasks = Array.from(scheduleListItems).map(item => {
            const taskId = parseInt(item.getAttribute('data-id'));
            const taskSrc = item.getAttribute('data-src');
            let task;
            let flag;

            if (taskSrc === 'rtn') {
                task = allTskRtn.find(t => t.id === taskId);
                flag = true;
            } else if (taskSrc === 'tsk') {
                task = allTasks.find(t => t.id === taskId);
                flag = true;
            } else {
                task = allMscRtn.find(t => t.id === taskId);
                flag = false;
            }
            if (task && flag) {
                return {
                    start_time: task.start_time,
                    duration: task.duration,
                    id: task.id, 
                    title: task.title,
                    category: task.category,
                    priority: task.priority,
                    is_repetitive: task.is_repetitive,
                    frequency_interval: task.frequency_interval,
                    due_date: task.due_date,
                    due_time: task.due_time,
                    color: task.color,
                    is_task: true,
                };
            } else if (task && !flag) {
                return {
                    start_time: task.start_time,
                    duration: task.duration,
                    title: task.title,
                    id: task.id,
                    is_task: false,
                }
            } else {
                console.error(`Task with ID ${taskId} not found!`);
                return null;
            }
        }).filter(task => task !== null); // Filter out null tasks

        // Check if there are valid tasks to save
        if (tasks.length === 0) {
            showMessage('No tasks to save', 'error');
            return;
        }

        // Send data to the backend
        const post_url = "{% url 'routine_save' %}";
        fetch(post_url, { // Replace with your actual API endpoint
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken,
            },
            body: JSON.stringify({
                for_date: forDate,
                tasks: tasks,
            }),
        })
        .then(response => {
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }
            return response.json();
        })
        .then(data => {
            showMessage(data.message, 'success');
            fetchRoutine(day);
            fetchTasks(day);
        })
        .catch(error => {
            console.error('Error saving routine:', error);
            alert('Failed to save routine. Please try again.'); // Provide user feedback
        });
    });

    // ENDING OF NEW FUNCTIONS

    // Function to show task detail
    async function showTaskDetail(taskId, source, item) {
        try {
            let taskDetail;
            let flag;

            // Determine which array to search based on the source parameter
            switch (source) {
            case 'tsk':
                taskDetail = allTasks.find(task => task.id === taskId);
                flag = true;
                break;
            case 'rtn':
                taskDetail = allTskRtn.find(task => task.id === taskId);
                flag = true;
                break;
            case 'msc':
                if (taskId.toString().length === 1) {
                    taskDetail = allMisc.find(task => task.id === taskId);
                } else {
                    taskDetail = allMscRtn.find(task => task.id === taskId);
                }
                flag = false;
                break;
            default:
                throw new Error('Invalid source parameter');
            }

            // Check if the task was found
            if (!taskDetail) {
            throw new Error('Task not found');
            }

            // Render the task details
            renderTaskDetail(taskDetail, flag, source, item);
        } catch (error) {
            console.error('Error fetching task details:', error);
        }
    }

    function getCSRFToken() {
      return document.cookie
        .split('; ')
        .find(row => row.startsWith('csrftoken='))
        ?.split('=')[1];
    }

    // Function to format time
    function formatTime(timeString) {
      const time = new Date(`1970-01-01T${timeString}`);
      return time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });
    }

    function formatDuration(minutes) {
      if (minutes === null || minutes === undefined) {
        return "N/A"; // Handle cases where duration is not available
      }

      const hours = Math.floor(minutes / 60);
      const remainingMinutes = minutes % 60;

      const formattedHours = String(hours).padStart(2, '0');
      const formattedMinutes = String(remainingMinutes).padStart(2, '0');
      if (formattedHours === `00`) {
        return `${formattedMinutes} Minutes`;
      } else {
        return `${formattedHours} hr ${formattedMinutes} min`;
      }

    }

    // Function to delete task
    async function delTask(taskId) {
      const csrftoken = getCSRFToken();
      try {
        const response = await fetch(`/api/task-delete/${taskId}/`, {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken,  // Add CSRF token header
            // Add authentication token if required
            // 'Authorization': `Bearer ${localStorage.getItem('access_token')}`
          },
        });

        if (!response.ok) {
          throw new Error('Failed to delete!');
        }

        const res = await response.json();
        showMessage(res.message, 'successs')
        const wardiv = document.querySelector('.warningdiv')
        const overlay = document.getElementById('overlay'); 
        if (wardiv) {
          wardiv.remove(); // Completely deletes the element
        }
        overlay.style.display = 'none';
        updateDateDisplay();

      } catch (error) {
        showMessage(error, 'error')
      }
    }

    // Function to render task detail
    function renderTaskDetail(task, flag, src, item) {
        const overlay = document.getElementById('overlay');
        const taskDetailContainer = document.getElementById('taskDetail');

        // Clear existing content
        taskDetailContainer.innerHTML = '';

        // Create and append elements
        const title = document.createElement('h4');
        title.innerHTML = `<i class="bi bi-check-square"></i> ${task.title}`; // Icon for title

        const durationContainer = createDurationInput(task.duration);

        // Append title and duration
        taskDetailContainer.appendChild(title);
        taskDetailContainer.appendChild(durationContainer);

        if (flag) {
            const category = document.createElement('p');
            category.innerHTML = `<i class="bi bi-tag"></i> Category: ${task.category ? task.category : 'Uncategorized'}`; // Icon for category

            const priority = document.createElement('p');
            priority.innerHTML = `<i class="bi bi-exclamation-circle"></i> Priority: ${getPriorityLabel(task.priority)}`; // Icon for priority

            taskDetailContainer.appendChild(category);
            taskDetailContainer.appendChild(priority);
        }

        // Okay Button
        const okayButton = document.createElement('button');
        okayButton.className = 'btn btn-primary';
        okayButton.innerHTML = `<i class="bi bi-check-circle"></i> Okay`; // Icon for Okay button
        okayButton.onclick = function () {
            closeTaskDetail(durationContainer, task.id, src, item);
        };
        okayButton.style.marginRight = '10px';

        // Append Okay button
        taskDetailContainer.appendChild(okayButton);

        // Only show Edit and Delete buttons if flag is false
        if (flag) {
            const editButton = document.createElement('button');
            editButton.className = 'btn btn-outline-secondary';
            editButton.innerHTML = `<i class="bi bi-pencil"></i> Edit`;
            editButton.style.marginRight = '10px';

            const editurl = `/task/edit_task/${task.id}/`;

            const deleteButton = document.createElement('button');
            deleteButton.className = 'btn btn-danger';
            deleteButton.innerHTML = `<i class="bi bi-trash"></i> Delete`;

            deleteButton.addEventListener('click', function () {
                const taskDetail = document.querySelector('.task-detail');
                const warningDiv = document.createElement('div');
                const bdy = document.getElementById('new-content');
                warningDiv.className = 'warningdiv';
                warningDiv.innerHTML = `
                    <div class="text-center">
                        <h5 class="mb-3">Deleting Task: <strong>${task.title}</strong></h5>
                        <p class="mb-2">Are you sure you want to delete this task?</p>
                        <p class="text-muted small mb-4">*This action can't be undone.</p>
                        <div class="d-flex justify-content-center">
                            <button class="btn btn-danger yes-button me-3">Delete</button>
                            <button class="btn btn-outline-secondary no-button">Cancel</button>
                        </div>
                    </div>
                `;

                taskDetail.style.display = 'none';
                bdy.appendChild(warningDiv);

                const noButton = warningDiv.querySelector('.no-button');
                noButton.addEventListener('click', function () {
                    warningDiv.style.display = 'none';
                    taskDetail.style.display = 'block';
                    warningDiv.remove();
                });

                const yesButton = warningDiv.querySelector('.yes-button');
                yesButton.onclick = () => delTask(task.id);
            });

            editButton.addEventListener('click', function () {
                $(document).trigger('contentUpdated', [editurl, '#new-content', true]);
            });

            // Append Edit and Delete buttons
            taskDetailContainer.appendChild(editButton);
            taskDetailContainer.appendChild(deleteButton);
        }

        // Show overlay and task detail
        overlay.style.display = 'block';
        taskDetailContainer.style.display = 'block';
    }


    // Function to close task detail
    function closeTaskDetail(durationContainer, taskId, taskSrc, item) {
        const overlay = document.getElementById('overlay');
        const taskDetailContainer = document.getElementById('taskDetail');
        const updatedDuration = getDurationInMinutes(durationContainer);
        // Add start_time to the task in the appropriate array (allTasks or allTskRtn)
        let taskIndex = -1;
        if (taskSrc === "rtn") {
            taskIndex = allTskRtn.findIndex(task => task.id === parseInt(taskId, 10));
            if (taskIndex !== -1) {
                allTskRtn[taskIndex].duration = updatedDuration; // Add start_time to the task in allTskRtn
            }
        } else if (taskSrc === "tsk") {
            taskIndex = allTasks.findIndex(task => task.id === parseInt(taskId, 10));
            if (taskIndex !== -1) {
                allTasks[taskIndex].duration = updatedDuration; // Add start_time to the task in allTasks
            }
        } else {
            if (taskId.toString().length === 1) {
                taskIndex = allMisc.findIndex(task => task.id === parseInt(taskId,10));
                if (taskIndex !== -1) {
                    allMisc[taskIndex].duration = updatedDuration;
                }
            } else {
                taskIndex = allMscRtn.findIndex(task => task.id === parseInt(taskId,10));
                if (taskIndex !== -1) {
                    allMscRtn[taskIndex].duration = updatedDuration;
                }
            }
        }
        updateTaskDuration(taskId, updatedDuration, item);    

        // Hide overlay and task detail
        overlay.style.display = 'none';
        taskDetailContainer.style.display = 'none';
        updateTimeSlots();
    }

    // Function to get duration in minutes
    function getDurationInMinutes(durationContainer) {
        const hoursInput = durationContainer.querySelector('input[placeholder="Hours"]');
        const minutesInput = durationContainer.querySelector('input[placeholder="Minutes"]');

        if (!hoursInput || !minutesInput) {
            console.error("Hours or minutes input not found in duration container.");
            return 0; // Or handle the error as needed
        }

        const hours = parseInt(hoursInput.value) || 0; // Parse hours, default to 0 if invalid
        const minutes = parseInt(minutesInput.value) || 0; // Parse minutes, default to 0 if invalid

        return hours * 60 + minutes;
    }


    // Function to create duration element
    function createDurationInput(durationInMinutes) {
        const durationContainer = document.createElement('div');
        durationContainer.innerHTML = `<i class="bi bi-clock"></i> Duration: `;

        const hoursInput = document.createElement('input');
        hoursInput.type = 'number';
        hoursInput.min = '0';
        hoursInput.placeholder = 'Hours';
        hoursInput.style.width = '50px';
        hoursInput.classList.add('duration-hour'); // Add class for event listener

        const minutesInput = document.createElement('input');
        minutesInput.type = 'number';
        minutesInput.min = '0';
        minutesInput.max = '59';
        minutesInput.placeholder = 'Minutes';
        minutesInput.style.width = '50px';
        minutesInput.classList.add('duration-minute'); // Add class for event listener

        const hours = Math.floor(durationInMinutes / 60);
        const minutes = durationInMinutes % 60;

        hoursInput.value = hours;
        minutesInput.value = minutes;

        durationContainer.appendChild(hoursInput);
        durationContainer.appendChild(document.createTextNode(' hr '));
        durationContainer.appendChild(minutesInput);
        durationContainer.appendChild(document.createTextNode(' min'));
        durationContainer.style.marginBottom = '15px';
        durationContainer.style.marginTop = '15px';

        // Attach event listeners to inputs
        hoursInput.addEventListener('input', handleInput);
        minutesInput.addEventListener('input', handleInput);

        return durationContainer;
    }

    function updateTaskDuration(taskId, duration, item) {
        // Helper function to update the duration of a task item
        function updateDuration(taskItem, newDuration) {
            const durationElement = taskItem.querySelector('.details span:first-child');
            if (durationElement) {
                durationElement.innerHTML = `<i class="bi bi-clock"></i> ${formatDuration(newDuration)}`;
            }
        }
        // Check if the provided 'item' is a valid DOM element
        if (item && item.nodeType === Node.ELEMENT_NODE) {
            // Update the duration directly on the provided item
            updateDuration(item, duration);
        } else {
            // If 'item' is not a valid element, log an error message
            console.error("Invalid task item provided to updateTaskDuration.");
        }
    }

    const dropzones = document.querySelectorAll(".task-list");

    dropzones.forEach(zone => {
        zone.addEventListener("dragover", function (event) {
            event.preventDefault();
            const dragging = document.querySelector(".dragging");
            if (!dragging) return;

            const draggingType = dragging.dataset.itemType;
            const destinationType = zone.dataset.type;

            // 🚫 Prevent dropping into 'misc-tasks' unless it's a 'misc' item
            if (zone.id === "misc-tasks" && draggingType !== "misc") return;

            // ✅ If item is from 'misc-tasks', only allow dropping into 'schedule-list'
            if (dragging.dataset.fromMisc === "true" && zone.id !== "schedule-list") {
                zone.classList.add("border-danger");
                return;
            }

            if (destinationType === "schedule" || destinationType === draggingType) {
                const afterElement = getDragAfterElement(zone, event.clientY);
                if (afterElement == null) {
                    zone.appendChild(dragging);
                } else {
                    zone.insertBefore(dragging, afterElement);
                }
            } else {
                zone.classList.add("border-danger");
            }
        });

        zone.addEventListener("drop", function (event) {
            event.preventDefault();
            const dragging = document.querySelector(".dragging");
            if (!dragging) return;

            dragging.classList.remove("dragging");
            dragging.style.opacity = "1";
            zone.classList.remove("border-danger");

            // ✅ Destroy only if:
            // 1. Dropped in 'misc-tasks' **AND** type is 'misc'
            // 2. A 'misc' task was dragged and dropped **outside** 'schedule-list'
            if (
                (zone.id === "misc-tasks" && dragging.dataset.itemType === "misc") ||
                (dragging.dataset.fromMisc === "true" && zone.id !== "schedule-list")
            ) {
                const taskIdToRemove = parseInt(dragging.dataset.id); // Get the ID to remove
                // Remove the task from allMscRtn
                allMscRtn = allMscRtn.filter(task => task.id !== taskIdToRemove);
                dragging.remove(); // Destroy the item
                updateTimeSlots();
                return;
            }

            if (zone.id === "schedule-list") {
                updateTimeSlots();
            } else if (zone.id === "one-time-tasks" || zone.id === "repetitive-tasks") {
                updateTimeSlots();
            }
        });

        zone.addEventListener("dragleave", function () {
            zone.classList.remove("over");
            zone.classList.remove("border-danger");
        });
    });

    // Function to make an element draggable
    function makeDraggable(task) {
        task.setAttribute("draggable", "true");

        task.addEventListener("dragstart", function (event) {
            event.dataTransfer.setData("text/plain", event.target.dataset.id);

            // 🟢 If dragging from 'misc-tasks', create a new independent item
            if (event.target.closest("#misc-tasks")) {
                // Get the data-id attribute from the dragged element
                const taskId = event.target.getAttribute("data-id");

                // Find the corresponding task in the allMisc array
                const task = allMisc.find(task => task.id == taskId);

                if (task) {
                    // Generate a new ID using the current time
                    const newId = Date.now(); // Unique ID based on timestamp

                    // Create a new task item using the task, new ID, and class name "x"
                    const xx = createMiscTask(task, newId, "x");
                    newItem = xx[0];

                    // Append the new item to #misc-tasks (instead of body)
                    const miscTasksContainer = document.getElementById("misc-tasks");
                    miscTasksContainer.appendChild(newItem);

                    // Add the "dragging" class to the new item
                    newItem.classList.add("dragging");

                    newItem.dataset.fromMisc = "true"; // Mark it as coming from misc
                    newItem.onclick = function () {
                        showTaskDetail(newId, 'msc', newItem);
                    }

                    // Keep the original item visible
                    event.target.style.opacity = "1";

                    // Hide the new item smoothly
                    setTimeout(() => newItem.style.opacity = "0", 0);

                    // Replace the dragging target with the new item
                    event.target = newItem;

                    // Create a copy of the task with the new ID and push it to allMscRtn
                    const newTaskForMscRtn = { ...task, id: newId }; // Create a shallow copy
                    allMscRtn.push(newTaskForMscRtn);
                }
            } else {
                // If not in the misc-tasks container, just add the dragging class and hide the original
                event.target.classList.add("dragging");
                setTimeout(() => event.target.style.opacity = "0", 0);
            }
        });

        task.addEventListener("dragend", function (event) {
            const dragging = document.querySelector(".dragging");
            if (dragging) {
                dragging.classList.remove("dragging");
                dragging.style.opacity = "1";

                // 🗑️ Destroy if it wasn't dropped anywhere (e.g., outside valid zones)
                if (!dragging.parentElement || dragging.parentElement === document.body) {
                    dragging.remove();
                }
            }
        });
    }

    // Function to create a brand new task item with the same attributes
    function createMiscTask(task, newId, className) {
        // Create a task item with necessary attributes
        const taskItem = $("<li></li>")
            .addClass("task-item misc") // Add 'misc' class
            .addClass(className) // Add the provided class name
            .attr("draggable", "true")
            .attr("data-id", newId) // Use the new ID provided
            .attr("data-item-type", "misc") // Always set as 'misc'
            .attr("data-src", "msc"); // Always set as 'msc'

        // Task Title with Relaxing Icon (zzz icon)
        const title = document.createElement('h4');
        title.className = 'task-title'; // Add a class for styling
        title.innerHTML = `
            <span class="title-icon"><i class="bi bi-emoji-dizzy"></i></span>
            <span class="title-text">${task.title}</span>
        `;

        // Task Details Container
        const details = document.createElement('div');
        details.className = 'details';

        // Duration with Icon
        const duration = document.createElement('span');
        duration.innerHTML = `<i class="bi bi-clock"></i> ${formatDuration(task.duration)}`; // Icon for duration

        // Append duration to details
        details.appendChild(duration);

        // Append both lines to the task item
        taskItem.append(title);
        taskItem.append(details);

        return taskItem;
    }

    // Function to get the correct insertion point in the list
    function getDragAfterElement(zone, y) {
        const draggableElements = [...zone.querySelectorAll(".task-item:not(.dragging)")];

        return draggableElements.reduce((closest, child) => {
            const box = child.getBoundingClientRect();
            const offset = y - (box.top + box.height / 2);
            return offset < 0 && offset > closest.offset ? { offset, element: child } : closest;
        }, { offset: Number.NEGATIVE_INFINITY }).element;
    }

    // Attach draggable functionality to existing task items
    document.querySelectorAll(".task-item").forEach(makeDraggable);

    // Observe dynamically added tasks
    const observer = new MutationObserver(mutations => {
        mutations.forEach(mutation => {
            mutation.addedNodes.forEach(node => {
                if (node.nodeType === 1 && node.classList.contains("task-item")) {
                    makeDraggable(node);
                }
            });
        });
    });

    // Start observing changes in the task lists
    dropzones.forEach(zone => {
        observer.observe(zone, { childList: true });
    });


    // Function to calculate and update time slots
    function updateTimeSlots() {
        const scheduleList = document.getElementById("schedule-list");
        const timeSlotsContainer = document.getElementById("time-slots");
        const dropzone = document.querySelector(".schedule .dropzone"); // Get the dropzone element

        timeSlotsContainer.innerHTML = ""; // Clear existing time slots
        let totalHeight = 0; // Variable to store the total height of all task items
        let counter = 0;

        let currentTime = new Date();
        currentTime.setHours(6, 0, 0, 0); // Start from 6:00 AM

        scheduleList.querySelectorAll(".task-item").forEach(taskItem => {
            const taskId = taskItem.dataset.id;
            const taskSrc = taskItem.dataset.src;
            const taskData = getTaskDataById(taskId, taskSrc); // Function to fetch task data

            if (taskData) {
                counter += 1;
                const taskHeight = taskItem.getBoundingClientRect().height;
                totalHeight += taskHeight + 4; // Add task height + 4px margin to the total height

                const durationMinutes = taskData.duration; // Assuming duration is in minutes
                const endTime = new Date(currentTime.getTime() + durationMinutes * 60000);

                // Format time in hh:mm AM/PM (uppercase)
                const formatOptions = { hour: '2-digit', minute: '2-digit', hour12: true };
                const startTimeString = currentTime.toLocaleTimeString([], formatOptions).toUpperCase();
                const endTimeString = endTime.toLocaleTimeString([], formatOptions).toUpperCase();

                // Save time in 24-hour format in the arrays
                const startTime24hr = currentTime.toISOString().slice(0, 16).replace('T', ' '); // Formats as "YYYY-MM-DD hh:mm"

                // Add start_time to the task in the appropriate array (allTasks, allTskRtn, or allMscRtn)
                let taskIndex = -1;
                if (taskSrc === "rtn") {
                    taskIndex = allTskRtn.findIndex(task => task.id === parseInt(taskId, 10));
                    if (taskIndex !== -1) {
                        allTskRtn[taskIndex].start_time = startTime24hr; // Save in 24-hour format
                    }
                } else if (taskSrc === "tsk") {
                    taskIndex = allTasks.findIndex(task => task.id === parseInt(taskId, 10));
                    if (taskIndex !== -1) {
                        allTasks[taskIndex].start_time = startTime24hr; // Save in 24-hour format
                    }
                } else {
                    taskIndex = allMscRtn.findIndex(task => task.id === parseInt(taskId, 10));
                    if (taskIndex !== -1) {
                        allMscRtn[taskIndex].start_time = startTime24hr; // Save in 24-hour format
                    }
                }

                const timeSlotDiv = document.createElement("div");
                timeSlotDiv.classList.add("time-slot");
                timeSlotDiv.style.height = `${taskHeight + 4}px`;

                const startTimeSpan = document.createElement("span");
                startTimeSpan.textContent = startTimeString; // Display in hh:mm AM/PM format

                const endTimeSpan = document.createElement("span");
                endTimeSpan.textContent = endTimeString; // Display in hh:mm AM/PM format

                timeSlotDiv.appendChild(startTimeSpan);
                timeSlotDiv.appendChild(endTimeSpan);

                timeSlotsContainer.appendChild(timeSlotDiv);

                currentTime = endTime; // Update current time for the next task
            }
        });

        // Set the total height to the dropzone
        dropzone.style.height = `${totalHeight + counter * 5}px`;
    }


    // Function to fetch task data by ID (now using the global arrays and taskSrc)
    function getTaskDataById(taskId, taskSrc) {
        if (taskSrc === "rtn") {
            return allTskRtn.find(task => task.id === parseInt(taskId));
        } else if (taskSrc === 'tsk') {
            return allTasks.find(task => task.id === parseInt(taskId));
        } else {
            return allMscRtn.find(task => task.id === parseInt(taskId));
        }
    }

    function handleInput(event) {
        const inputValue = event.target.value;
        const numericValue = inputValue.replace(/[^0-9]/g, ''); // Remove non-numeric characters

        let value = parseInt(numericValue, 10);

        if (isNaN(value)) {
            value = ''; // Clear the field if input is not a number
        } else {
            if (event.target.classList.contains('duration-hour')) {
                // Hour field for duration (0-23)
                if (value < 0) value = 0;
                if (value > 23) value = 23;
            } else if (event.target.classList.contains('duration-minute')) {
                // Minute field for duration (0-59)
                if (value < 0) value = 0;
                if (value > 59) value = 59;
                value = value.toString().padStart(2, '0'); // Ensure two digits
            }
        }

        event.target.value = value;
    };
});

</script>