<style>
  /* Custom CSS for Search Bar and Sort Button */
  .search-bar {
    flex-grow: 1; /* Ensures the search bar takes up remaining space */
    position: relative; /* Required for absolute positioning of the button */
  }

  .search-bar input {
    width: 100%; /* Full width */
    padding-right: 2rem; /* Space for the search icon */
    background-color: #ffffff; /* White background */
    color: #495057; /* Dark text */
    border: 1px solid #e0e0e0; /* Light border */
  }

  /* Custom styles for the search button */
  .search-button {
    background-color: #e9ecef; /* Match the default Bootstrap input background color */
    border: 1px solid #e0e0e0; /* Remove the border */
    padding: 0.25rem 0.5rem; /* Adjust padding to match the input */
    color: #6c757d; /* Match the icon color to the input placeholder color */
    transition: background-color 0.2s, color 0.2s; /* Smooth hover effect */
    position: absolute; /* Position the button absolutely within the search bar */
    top: 50%; /* Center vertically */
    right: 1px; /* Adjust horizontal position */
    transform: translateY(-50%); /* Fine-tune vertical centering */
  }

  .search-button:hover {
    background-color: #dee2e6; /* Slightly darker background on hover */
    color: #495057; /* Slightly darker icon color on hover */
  }



  .dropdown {
    flex-shrink: 0;
    /* Prevents the sort button from shrinking */
  }

  .task-container {
    display: flex;
    gap: 1rem;
    margin-top: 1rem;
  }

  @media (max-width: 768px) {
    .task-container {
      flex-direction: column;
    }
  }

  /* General Scrollbar Styling (WebKit) */
  .task-list::-webkit-scrollbar {
    width: 8px;
    /* Adjust width as needed */
  }

  .task-list::-webkit-scrollbar-track {
    background: #f1f1f1;
    /* Light background for the track */
    border-radius: 4px;
  }

  .task-list::-webkit-scrollbar-thumb {
    background: #888;
    /* Medium gray for the thumb */
    border-radius: 4px;
  }

  .task-list::-webkit-scrollbar-thumb:hover {
    background: #555;
    /* Darker gray on hover */
  }

  /* Firefox Scrollbar Styling (Limited) */
  .task-list {
    scrollbar-width: thin;
    /* For Firefox */
    scrollbar-color: #888 #f1f1f1;
    /* Thumb and track colors */
  }

  .outerbox {
    display: flex;
    flex-direction: column;
    flex: 1;
    /* Ensure both outerboxes take equal space */
    gap: 2px;
    /* Add spacing between the header and task list */
  }

  .task-list {
    flex: 1;
    padding: 1rem;
    background: #ffffff;
    border-radius: 8px;
    border: 1px solid #e0e0e0;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
    max-height: calc(100dvh - 24dvh);
    overflow-y: auto;
    position: relative;
  }

  .task-list h3 {
    position: sticky;
    top: 0;
    z-index: 10;
    /* Stay above the scrolling content */
    margin: 0;
    /* Remove default margin */
    background-color: inherit;
    /* Inherit background color from parent */
    padding: 0;
    /* Remove default padding */
  }

  .task-list h3 .fs-4 {
    background-color: rgb(141, 11, 11);
    /* Or rgb(61, 38, 190) for the other header */
    color: white;
    text-align: center;
    padding: 10px;
    border-radius: 8px;
    margin: 0;
    /* Remove default margin */
    display: block;
    /* Ensure the div behaves as a block element */
  }

  .task-card {
    padding: 0.75rem;
    margin-bottom: 0.75rem;
    border-radius: 6px;
    cursor: pointer;
    transition: transform 0.2s ease, box-shadow 0.2s ease;
    font-size: 0.975rem;
    background-color: var(--task-bg-color);
  }

  .task-card:hover {
    transform: translateY(-1px);
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.35);
  }

  .task-card.low {
    background-color: #A8E0A0;
  }

  .task-card.medium {
    background-color: #FFFFA0;
  }

  .task-card.high {
    background-color: #FFC870;
  }

  .task-card.critical {
    background-color: #FF8A80;
  }

  .task-card.urgent {
    background-color: #D0312D;
    color: white; /* Ensure readability */
  }

  .task-card .details {
    display: flex;
    gap: 0.75rem;
    align-items: center;
    margin-top: 0.5rem;
    font-size: 0.95rem;
    color: #6c757d;
  }

  .task-card .details .separator {
    width: 1px;
    height: 0.75rem;
    background-color: #e0e0e0;
  }

  @media (max-width: 768px) {
    .task-card .details {
      flex-direction: column;
      align-items: flex-start;
      gap: 0.25rem;
    }

    .task-card .details .separator {
      display: none;
    }

    .task-list {
      max-height: 73dvh;
    }
  }

  .task-detail {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #ffffff;
    padding: 1.5rem;
    border-radius: 8px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
    z-index: 999;
    font-size: 0.975rem;
    width: 80vw;
    /* Set width to 80% of the viewport width */
    max-width: 500px;
    /* Optional: set a maximum width */
  }

  .overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    z-index: 998;
  }

  .badge {
    font-size: 0.625rem;
    padding: 0.2rem 0.4rem;
    border-radius: 4px;
    font-weight: 500;
  }

  .badge.up {
    background-color: #dc3545;
    color: #ffffff;
  }

  .badge.down {
    background-color: #28a745;
    color: #ffffff;
  }

  .tab-view {
    display: none;
  }

  .task-title {
    display: flex;
    align-items: center;
    /* Align icon and text vertically */
    gap: 8px;
    /* Space between icon and text */
    font-size: 18px;
    /* Adjust font size */
    font-weight: 600;
    /* Make the title bold */
    color: #333;
    /* Darker text for better readability */
    margin-bottom: 12px;
    /* Add space below the title */
  }

  .title-icon {
    font-size: 20px;
    /* Slightly larger icon */
    color: #007bff;
    /* Icon color matching your theme */
  }

  .title-text {
    flex: 1;
    /* Allow text to take remaining space */
  }

  @media (max-width: 768px) {
    .task-container {
      display: none;
    }

    .tab-view {
      display: block;
    }

    .tab-buttons {
      display: flex;
      gap: 0.75rem;
      margin-bottom: 1rem;
    }

    .tab-buttons button {
      flex: 1;
      padding: 0.5rem;
      border: 1px solid #e0e0e0;
      border-radius: 6px;
      background: #ffffff;
      cursor: pointer;
      font-size: 1rem;
      transition: background-color 0.2s ease;
    }

    .tab-buttons button.active {
      background: #007bff;
      color: #ffffff;
      border-color: #007bff;
    }

    .task-title {
      font-size: 16px;
      gap: 6px;
    }

    .title-icon {
      font-size: 18px;
    }
  }


  /* Dark Theme Styles */
  body.dark-theme {
    background-color: #121212;
    /* Dark background */
    color: #e0e0e0;
    /* Light text */
  }

  /* Dark Theme */
  body.dark-theme .search-input {
    background-color: #333; /* Dark background */
    color: #e0e0e0; /* Light text */
    border: 1px solid #444; /* Dark border */
  }

  body.dark-theme .search-button {
    background-color: #444; /* Darker background for dark mode */
    color: #e0e0e0; /* Light icon color for dark mode */
    border: #444;
  }

  body.dark-theme .search-button:hover {
    background-color: #555; /* Slightly lighter background on hover */
    color: #ffffff; /* Brighter icon color on hover */
  }

  body.dark-theme .search-input::placeholder {
    color: #e0e0e0;
    /* White or light-colored placeholder text */
    opacity: 1;
    /* Ensure full opacity for consistent visibility */
  }

  body.dark-theme .dropdown .sortDropdown {
    background-color: #343a40;
    /* Darker background for dark mode */
    color: #f8f9fa;
    /* Light text color for dark mode */
    border-color: #6c757d;
    /* Slightly lighter border for dark mode */
  }

  body.dark-theme .dropdown .btn.btn-outline-secondary {
    background-color: #343a40; /* Darker background for dark mode */
    color: #f8f9fa !important; /* Light text color for dark mode */
    border-color: #6c757d; /* Slightly lighter border for dark mode */
  }

  body.dark-theme .dropdown .btn.btn-outline-secondary:hover {
    background-color: #454d55; /* Slightly lighter background on hover */
    color: #ffffff !important; /* Ensure text stays bright on hover */
  }


  /* Dark Theme for Task List */
  body.dark-theme .task-list {
    background-color: #222;
    /* Dark background */
    border-color: #444;
    /* Darker border */
  }

  body.dark-theme .task-list .details {
    color: #e0e0e0;
  }

  /* Dark Theme for Task Title */
  body.dark-theme .task-title {
    color: #e0e0e0;
    /* Light text */
  }

  body.dark-theme .task-card {
      background-color: var(--task-dark-bg-color);
  }

  body.dark-theme .task-card:hover {
    box-shadow: 0 2px 4px rgba(255, 255, 255, 0.55);
  }

  body.dark-theme .task-card.high {
    background-color: #442222;
    /* Darker red */
  }

  body.dark-theme .task-card.medium {
    background-color: #443322;
    /* Darker orange */
  }

  body.dark-theme .task-card.low {
    background-color: #224422;
    /* Darker green */
  }

  /* Dark Theme for Task Details */
  body.dark-theme .task-detail {
    background-color: #333;
    /* Dark background */
    color: #e0e0e0;
    /* Light text */
  }

  /* Dark Theme for Overlay */
  body.dark-theme .overlay {
    background: rgba(0, 0, 0, 0.7);
    /* Darker overlay */
  }

  /* Dark Theme for Scrollbar */
  body.dark-theme .task-list::-webkit-scrollbar-track {
    background: #444;
    /* Dark track */
  }

  body.dark-theme .task-list::-webkit-scrollbar-thumb {
    background: #666;
    /* Light thumb */
  }

  body.dark-theme .task-list {
    scrollbar-color: #666 #444;
    /* Thumb and track colors for Firefox */
  }

  /* Dark Theme for Tab Buttons */
  body.dark-theme .tab-buttons button {
    background-color: #333;
    /* Dark background */
    border-color: #444;
    /* Darker border */
    color: #e0e0e0;
    /* Light text */
  }

  body.dark-theme .tab-buttons button.active {
    background-color: #326294;
    /* Active button color */
    color: #ffffff;
    /* White text */
  }

  /* Dark Theme for Separator */
  body.dark-theme .task-card .details .separator {
    background-color: #555;
    /* Darker separator */
  }

  /* Dark Theme for Buttons */
  body.dark-theme .btn-primary {
    background-color: #0056b3; /* Keep primary button color */
    color: #ffffff; /* Light text */
  }

  body.dark-theme .btn-primary:hover {
    background-color: #004085; /* Darker hover color */
  }

  body.dark-theme .btn-outline-secondary {
    border-color: #6c757d; /* Keep border color */
    color: #e0e0e0; /* Keep text color */
  }

  body.dark-theme .btn-outline-secondary:hover {
    background-color: #6c757d; /* Keep hover background color */
    color: #ffffff; /* Light text */
  }
</style>

{% load static %}
<div class="img-background" style="background: url('{% static "img/back1.png" %}') no-repeat center center;"></div>

<!-- Search Bar and Sort Button -->
<div class="d-flex align-items-center gap-3 w-100" style="margin-bottom: 1rem;">

  <!-- Sort Button with Dropdown -->
  <div class="dropdown">
    <button class="btn btn-outline-secondary btn-sm dropdown-toggle" type="button" id="sortDropdown"
      data-bs-toggle="dropdown" aria-expanded="false">
      Sort by: Priority
    </button>
    <ul class="dropdown-menu" aria-labelledby="sortDropdown">
      <li><a class="dropdown-item" data-sort="priority">Priority</a></li>
      <li><a class="dropdown-item" data-sort="title">Title</a></li>
      <li><a class="dropdown-item" data-sort="due_date">Due Date</a></li>
      <li><a class="dropdown-item" data-sort="duration">Duration</a></li>
      <li><a class="dropdown-item" data-sort="added">Added Date</a></li>
      <li><a class="dropdown-item" data-sort="updated">Updated Date</a></li>
      <li><a class="dropdown-item" data-sort="task_merit">Merit</a></li>
    </ul>
  </div>

  <!-- Search Bar -->
  <div class="flex-grow-1 position-relative">
    <form id="searchForm">
      <input type="text" id="searchInput" class="form-control form-control-sm search-input" placeholder="Search tasks...">
      <!-- Search btn Icon -->
      <button type="submit" id="searchButton" class="btn btn-sm position-absolute top-50 end-0 translate-middle-y search-button">
        <i class="fas fa-search search-icon"></i>
      </button>
    </form>
  </div>
</div>

<!-- Desktop View -->
<div class="task-container">
  <div class="outerbox flex-column">
    <h3>
      <div class='fs-4'
        style='text-align: center; background-color: rgb(141, 11, 11); color: white; padding: 10px; border-radius: 8px;'>
        Upcoming One-Time Tasks</div>
    </h3>
    <div class="task-list">
      <div id="onetime-tab"></div>
    </div>
  </div>
  <div class="outerbox flex-column">
    <h3>
      <div class='fs-4'
        style='text-align: center; background-color: rgb(61, 38, 190); color: white; padding: 10px; border-radius: 8px;'>
        Repetitive Tasks</div>
    </h3>
    <div class="task-list">
      <div id="repetitive-tab"></div>
    </div>
  </div>
</div>

<!-- Mobile Tab View -->
<div class="tab-view">
  <div class="tab-buttons">
    <button onclick="showTab('onetime')" class="active">One-Time Tasks</button>
    <button onclick="showTab('repetitive')">Repetitive Tasks</button>
  </div>
  <div id="mobile-onetime-tab" class="task-list"></div>
  <div id="mobile-repetitive-tab" class="task-list" style="display: none;"></div>
</div>

<!-- Task Detail Overlay -->
<div class="overlay" id="overlay" style="display: none;"></div>
<div class="task-detail" id="taskDetail" style="display: none;">
</div>

<script>
  // Wrap your script logic in a function
  function initializeTaskManager() {
    // Fetch tasks from the backend
    fetchTasks();

    // Function to fetch tasks
    async function fetchTasks(query = '') {
      try {
        // Build the URL with the query parameter if provided
        const url = query ? `{% url "task_list" %}?q=${encodeURIComponent(query)}` : '{% url "task_list" %}';

        const response = await fetch(url, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            // Add authentication token if required
            // 'Authorization': `Bearer ${localStorage.getItem('access_token')}`
          },
        });

        if (!response.ok) {
          throw new Error('Failed to fetch tasks');
        }

        const tasks = await response.json();
        renderTasks(tasks); // Render the tasks in the UI
      } catch (error) {
        console.error('Error fetching tasks:', error);
      }
    }

    // Function to render tasks
    function renderTasks(tasks) {
      const repetitiveTasksContainerDesktop = document.querySelector('#repetitive-tab');
      const oneTimeTasksContainerDesktop = document.querySelector('#onetime-tab');
      const repetitiveTasksContainerMobile = document.querySelector('#mobile-repetitive-tab');
      const oneTimeTasksContainerMobile = document.querySelector('#mobile-onetime-tab');

      // Clear existing tasks
      repetitiveTasksContainerDesktop.innerHTML = '';
      oneTimeTasksContainerDesktop.innerHTML = '';
      repetitiveTasksContainerMobile.innerHTML = '';
      oneTimeTasksContainerMobile.innerHTML = '';

      // Filter tasks into repetitive and one-time
      const repetitiveTasks = tasks.filter(task => task.is_repetitive);
      const oneTimeTasks = tasks.filter(task => !task.is_repetitive);

      // Render repetitive tasks or "No Task Here" message
      if (repetitiveTasks.length > 0) {
        repetitiveTasks.forEach(task => {
          const taskCard = createTaskCard(task); // Create the task card element
          const taskCardClone = taskCard.cloneNode(true); // Clone the task card for desktop

          // Attach the onclick event handler to the cloned task card
          taskCardClone.onclick = () => showTaskDetail(task.id);

          repetitiveTasksContainerDesktop.appendChild(taskCardClone); // Append clone to desktop
          repetitiveTasksContainerMobile.appendChild(taskCard); // Append original to mobile
        });
      } else {
        const noTaskMessage = document.createElement('div');
        noTaskMessage.textContent = 'No Task Here';
        noTaskMessage.style.textAlign = 'center';
        noTaskMessage.style.color = '#888';
        noTaskMessage.style.padding = '1rem';

        repetitiveTasksContainerDesktop.appendChild(noTaskMessage.cloneNode(true)); // Append to desktop
        repetitiveTasksContainerMobile.appendChild(noTaskMessage.cloneNode(true)); // Append to mobile
      }

      // Render one-time tasks or "No Task Here" message
      if (oneTimeTasks.length > 0) {
        oneTimeTasks.forEach(task => {
          const taskCard = createTaskCard(task); // Create the task card element
          const taskCardClone = taskCard.cloneNode(true); // Clone the task card for desktop

          // Attach the onclick event handler to the cloned task card
          taskCardClone.onclick = () => showTaskDetail(task.id);

          oneTimeTasksContainerDesktop.appendChild(taskCardClone); // Append clone to desktop
          oneTimeTasksContainerMobile.appendChild(taskCard); // Append original to mobile
        });
      } else {
        const noTaskMessage = document.createElement('div');
        noTaskMessage.textContent = 'No Task Here';
        noTaskMessage.style.textAlign = 'center';
        noTaskMessage.style.color = '#888';
        noTaskMessage.style.padding = '1rem';

        oneTimeTasksContainerDesktop.appendChild(noTaskMessage.cloneNode(true)); // Append to desktop
        oneTimeTasksContainerMobile.appendChild(noTaskMessage.cloneNode(true)); // Append to mobile
      }
    }



    // Function to create a task card ${getPriorityClass(task.priority)}
    function createTaskCard(task) {
      const taskCard = document.createElement('div');
      taskCard.className = `task-card task-${task.id}`;
      taskCard.onclick = () => showTaskDetail(task.id);

      if (task.color) {
        const darkerColor = darkenHexColor(task.color, 0.1);

        // Set CSS variables for the task card
        taskCard.style.setProperty('--task-bg-color', task.color);
        taskCard.style.setProperty('--task-dark-bg-color', darkerColor);
    }

      // Task Title with Icon
      const title = document.createElement('h4');
      title.className = 'task-title'; // Add a class for styling
      title.innerHTML = `
          <span class="title-icon"><i class="bi bi-card-heading"></i></span>
          <span class="title-text">${task.title}</span>
      `;

      // Task Details Container
      const details = document.createElement('div');
      details.className = 'details';

      // Duration with Icon
      const duration = document.createElement('span');
      duration.innerHTML = `<i class="bi bi-clock"></i> ${formatDuration(task.duration)}`; // Icon for duration

      // Category with Icon
      const category = document.createElement('span');
      category.innerHTML = `<i class="bi bi-tag"></i> ${task.category ? task.category : 'Uncategorized'}`; // Icon for category

      // Due Date with Icon
      let dueDate = null;
      if (task.is_repetitive) {
        dueDate = document.createElement('span');
        dueDate.innerHTML = `<i class="bi bi-calendar-repeat"></i> ${task.frequency_interval === 1 ? 'Repeats everyday' : `Repeats in every ${task.frequency_interval ? task.frequency_interval : 'Undefined'} days`}`; // Icon for repetitive tasks
      } else {
        dueDate = document.createElement('span');
        dueDate.innerHTML = `<i class="bi bi-calendar-event"></i> Due: ${formatDate(task.due_date)} At ${task.due_time ? formatTime(task.due_time) : 'anytime'}`; // Icon for due date
      }

      // Priority Badge with Icon
      const priorityBadge = document.createElement('span');
      priorityBadge.className = `badge ${getPriorityBadgeClass(task.priority)}`;
      priorityBadge.innerHTML = `<i class="bi bi-exclamation-circle"></i> ${getPriorityLabel(task.priority)} Priority`; // Icon for priority
      priorityBadge.style.marginLeft = 'auto'; // Push the badge to the right

      // Append elements to details
      details.appendChild(duration);
      details.appendChild(createSeparator());
      details.appendChild(category);
      details.appendChild(createSeparator());
      details.appendChild(dueDate);
      details.appendChild(createSeparator());
      details.appendChild(priorityBadge);

      // Append elements to task card
      taskCard.appendChild(title);
      taskCard.appendChild(details);

      return taskCard;
    }

    // Function to create a separator
    function createSeparator() {
      const separator = document.createElement('div');
      separator.className = 'separator';
      return separator;
    }

    // Dark color for dark theme background
      function darkenHexColor(hex, factor) {
        // Remove the '#' if it exists
        hex = hex.replace(/^#/, '');

        // Parse the HEX into RGB components
        let r = parseInt(hex.slice(0, 2), 16) / 255;
        let g = parseInt(hex.slice(2, 4), 16) / 255;
        let b = parseInt(hex.slice(4, 6), 16) / 255;

        // Convert RGB to HSL
        let max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h, s, l = (max + min) / 2;

        if (max === min) {
            h = s = 0; // achromatic
        } else {
            let d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }

        // Adjust lightness to make the color darker
        l = l * factor;

        // Slightly increase saturation to make the color richer
        s = Math.min(s * 1.2, 1); // Limit saturation to 1 to avoid oversaturation

        // Convert HSL back to RGB
        let q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        let p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);

        // Convert RGB back to HEX
        r = Math.round(r * 255);
        g = Math.round(g * 255);
        b = Math.round(b * 255);
        return `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).padStart(6, '0')}`;
    }

    function hue2rgb(p, q, t) {
        if (t < 0) t += 1;
        if (t > 1) t -= 1;
        if (t < 1/6) return p + (q - p) * 6 * t;
        if (t < 1/2) return q;
        if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
        return p;
    }
    // Function to get priority class
    function getPriorityClass(priority) {
      switch (priority) {
        case 1:
          return 'low';
        case 2:
          return 'medium';
        case 3:
          return 'high';
        case 4:
          return 'urgent';
        case 5:
          return 'critical';
        default:
          return '';
      }
    }

    // Function to get priority badge class
    function getPriorityBadgeClass(priority) {
      return priority >= 3 ? 'up' : 'down';
    }

    // Function to get priority label
    function getPriorityLabel(priority) {
      switch (priority) {
        case 1:
          return 'Low';
        case 2:
          return 'Medium';
        case 3:
          return 'High';
        case 4:
          return 'Urgent';
        case 5:
          return 'Critical';
        default:
          return '';
      }
    }

    // Function to format date
    function formatDate(dateString) {
      const date = new Date(dateString);
      const options = { year: 'numeric', month: 'long', day: '2-digit' };
      return date.toLocaleDateString('en-US', options);
    }

    function formatDuration(minutes) {
      if (minutes === null || minutes === undefined) {
        return "Duration: N/A"; // Handle cases where duration is not available
      }

      const hours = Math.floor(minutes / 60);
      const remainingMinutes = minutes % 60;

      const formattedHours = String(hours).padStart(2, '0');
      const formattedMinutes = String(remainingMinutes).padStart(2, '0');
      if (formattedHours === `00`) {
        return `Duration: ${formattedMinutes} Minutes`;
      } else {
        return `Duration: ${formattedHours} hr ${formattedMinutes} min`;
      }

    }

    // Function to format time
    function formatTime(timeString) {
      const time = new Date(`1970-01-01T${timeString}`);
      return time.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit', hour12: true });
    }
    // Function to show task detail
    async function showTaskDetail(taskId) {
      try {
        // const baseUrl = window.location.origin;
        const response = await fetch(`/api/task-detail/${taskId}/`, {
          method: 'GET',
          headers: {
            'Content-Type': 'application/json',
            // Add authentication token if required
            // 'Authorization': `Bearer ${localStorage.getItem('access_token')}`
          },
        });

        if (!response.ok) {
          throw new Error('Failed to fetch task details');
        }

        const taskDetail = await response.json();
        renderTaskDetail(taskDetail);
      } catch (error) {
        console.error('Error fetching task details:', error);
      }
    }

    function getCSRFToken() {
      return document.cookie
        .split('; ')
        .find(row => row.startsWith('csrftoken='))
        ?.split('=')[1];
    }

    // Function to delete task
    async function delTask(taskId) {
      const csrftoken = getCSRFToken();
      try {
        const response = await fetch(`/api/task-delete/${taskId}/`, {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json',
            'X-CSRFToken': csrftoken,  // Add CSRF token header
            // Add authentication token if required
            // 'Authorization': `Bearer ${localStorage.getItem('access_token')}`
          },
        });

        if (!response.ok) {
          throw new Error('Failed to delete!');
        }

        const res = await response.json();
        showMessage(res.message, 'successs')
        const wardiv = document.querySelector('.warningdiv')
        const overlay = document.getElementById('overlay'); 
        if (wardiv) {
          wardiv.remove(); // Completely deletes the element
        }
        overlay.style.display = 'none';
        fetchTasks()

      } catch (error) {
        showMessage(error, 'error')
      }
    }

    // Function to render task detail
    function renderTaskDetail(task) {
      const overlay = document.getElementById('overlay');
      const taskDetailContainer = document.getElementById('taskDetail');

      // Clear existing content
      taskDetailContainer.innerHTML = '';

      // Create and append elements
      const title = document.createElement('h4');
      title.innerHTML = `<i class="bi bi-card-heading"></i> ${task.title}`; // Icon for title

      const duration = document.createElement('p');
      duration.innerHTML = `<i class="bi bi-clock"></i> ${formatDuration(task.duration)}`; // Icon for duration

      const category = document.createElement('p');
      category.innerHTML = `<i class="bi bi-tag"></i> Category: ${task.category ? task.category : 'Uncategorized'}`; // Icon for category

      const priority = document.createElement('p');
      priority.innerHTML = `<i class="bi bi-exclamation-circle"></i> Priority: ${getPriorityLabel(task.priority)}`; // Icon for priority

      const dueDate = document.createElement('p');
      if (task.is_repetitive) {
        dueDate.innerHTML = `<i class="bi bi-calendar-event"></i> Next Due: ${formatDate(task.due_date)} <br>-->Frequency: ${task.frequency_interval === 1 ? 'Daily' : `Repeats in every ${task.frequency_interval ? task.frequency_interval : 'Undefined'} days`}`; // Icon for repetitive tasks
      } else {
        dueDate.innerHTML = `<i class="bi bi-calendar-event"></i> Due: ${formatDate(task.due_date)}<br>-->At ${task.due_time ? formatTime(task.due_time) : 'anytime'}`; // Icon for due date
      }

      const description = document.createElement('p');
      description.innerHTML = `<i class="bi bi-card-text"></i> Description: ${task.description || 'No description'}`; // Icon for description

      // Buttons
      const okayButton = document.createElement('button');
      okayButton.className = 'btn btn-primary';
      okayButton.innerHTML = `<i class="bi bi-check-circle"></i> Okay`; // Icon for Okay button
      okayButton.onclick = closeTaskDetail;
      okayButton.style.marginRight = '10px'; // Add right margin

      const editButton = document.createElement('button');
      editButton.className = 'btn btn-outline-secondary';
      editButton.innerHTML = `<i class="bi bi-pencil"></i> Edit`; // Icon for Edit button
      editButton.style.marginRight = '10px';

      const editurl = `/task/edit_task/${task.id}/`

      const deleteButton = document.createElement('button');
      deleteButton.className = 'btn btn-danger';
      deleteButton.innerHTML = `<i class="bi bi-trash"></i> Delete`;

      deleteButton.addEventListener('click', function () {
        const taskDetail = document.querySelector('.task-detail');
        const warningDiv = document.createElement('div');
        const bdy = document.getElementById('new-content');
        warningDiv.className = 'warningdiv';
        warningDiv.innerHTML = `
            <div class="text-center">
                <h5 class="mb-3">Deleting Task: <strong>${task.title}</strong></h5>
                <p class="mb-2">Are you sure you want to delete this task?</p>
                <p class="text-muted small mb-4">*This action can't be undone.</p>
                <div class="d-flex justify-content-center">
                    <button class="btn btn-danger yes-button me-3">Delete</button>
                    <button class="btn btn-outline-secondary no-button">Cancel</button>
                </div>
            </div>
        `;

        taskDetail.style.display = 'none';
        bdy.appendChild(warningDiv);

        const noButton = warningDiv.querySelector('.no-button');
        noButton.addEventListener('click', function () {
          warningDiv.style.display = 'none';
          taskDetail.style.display = 'block';
          warningDiv.remove();
        });

        const yesButton = warningDiv.querySelector('.yes-button');
        yesButton.onclick = () => delTask(task.id);
      });

      editButton.addEventListener('click', function () {
        $(document).trigger('contentUpdated', [editurl, '#new-content', true]);
      });

      // Append elements to task detail container
      taskDetailContainer.appendChild(title);
      taskDetailContainer.appendChild(duration);
      taskDetailContainer.appendChild(category);
      taskDetailContainer.appendChild(priority);
      taskDetailContainer.appendChild(dueDate);
      taskDetailContainer.appendChild(description);
      taskDetailContainer.appendChild(okayButton);
      taskDetailContainer.appendChild(editButton);
      taskDetailContainer.appendChild(deleteButton);

      // Show overlay and task detail
      overlay.style.display = 'block';
      taskDetailContainer.style.display = 'block';
    }

    // Function to close task detail
    function closeTaskDetail() {
      const overlay = document.getElementById('overlay');
      const taskDetailContainer = document.getElementById('taskDetail');

      // Hide overlay and task detail
      overlay.style.display = 'none';
      taskDetailContainer.style.display = 'none';
    }


    // Tab switching functionality
    function showTab(tabName) {
      const repetitiveTab = document.getElementById('mobile-repetitive-tab');
      const oneTimeTab = document.getElementById('mobile-onetime-tab');
      const tabButtons = document.querySelectorAll('.tab-buttons button');

      if (tabName === 'repetitive') {
        repetitiveTab.style.display = 'block';
        oneTimeTab.style.display = 'none';
        tabButtons[1].classList.add('active');
        tabButtons[0].classList.remove('active');
      } else if (tabName === 'onetime') {
        repetitiveTab.style.display = 'none';
        oneTimeTab.style.display = 'block';
        tabButtons[1].classList.remove('active');
        tabButtons[0].classList.add('active');
      }
    }

    // Attach tab switching event listeners
    document.querySelectorAll('.tab-buttons button').forEach(button => {
      button.addEventListener('click', () => showTab(button.getAttribute('onclick').match(/'(\w+)'/)[1]));
    });


    // search button function
    // Get the form and input elements
    const searchForm = document.getElementById('searchForm');
    const searchInput = document.getElementById('searchInput');

    // Attach event listener to the form
    searchForm.addEventListener('submit', function (event) {
      event.preventDefault(); // Prevent the form from submitting the traditional way
      const query = searchInput.value.trim(); // Get the search query
      fetchTasks(query); // Fetch tasks with the search query
    });

    // Sort function:
    function sortAction() {
      const dropdownButton = document.getElementById('sortDropdown');
      const dropdownItems = document.querySelectorAll('#sortDropdown + .dropdown-menu .dropdown-item');
      const sortKey = 'sortPreference'; // Key for local storage
      const lineanim = document.querySelector('#loading-line')
      const searchInput = document.getElementById('searchInput');

      // Function to update the dropdown button text
      function updateDropdownText(selectedItem) {
        // Use the text content of the selected dropdown item
        dropdownButton.textContent = `Sort by: ${selectedItem.textContent}`;
      }

      // Function to send a POST request to update the sort preference
      async function updateSortPreference(sortValue) {
        try {
          const response = await fetch('/api/update-sort/', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json',
              'X-CSRFToken': getCSRFToken(), // Include CSRF token for Django
            },
            body: JSON.stringify({ sort: sortValue }),
          });

          if (response.ok) {
            const query = searchInput.value.trim();
            if (query !== ""){
              fetchTasks(query)
            } else {
              fetchTasks()
            }
          } else {
            showMessage('Error!', 'error');
          }
        } catch (error) {
          console.error('Error:', error);
        }
      }

      // Load saved sort preference from local storage
      const savedSortPreference = localStorage.getItem(sortKey);
      if (savedSortPreference) {
        // Find the corresponding dropdown item and update the button text
        const correspondingItem = Array.from(dropdownItems).find(item => item.getAttribute('data-sort') === savedSortPreference);
        if (correspondingItem) {
          updateDropdownText(correspondingItem);
        }
      }

      // Add event listeners to dropdown items
      dropdownItems.forEach(item => {
        item.addEventListener('click', function (e) {
          e.preventDefault();
          const sortValue = this.getAttribute('data-sort');

          // Update dropdown text with the clicked item's text content
          updateDropdownText(this);

          // Save the selected value to local storage
          localStorage.setItem(sortKey, sortValue);

          // Send a POST request to update the sort preference
          updateSortPreference(sortValue);
        });
      });
    }
    sortAction();

  }

  // Call the initialization function after the AJAX content is loaded
  initializeTaskManager();
</script>